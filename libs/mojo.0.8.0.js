!function(e){var t={};function n(c){if(t[c])return t[c].exports;var l=t[c]={i:c,l:!1,exports:{}};return e[c].call(l.exports,l,l.exports,n),l.l=!0,l.exports}n.m=e,n.c=t,n.d=function(e,t,c){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:c})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var c=Object.create(null);if(n.r(c),Object.defineProperty(c,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var l in e)n.d(c,l,function(t){return e[t]}.bind(null,l));return c},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=10)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _default; });\n/* harmony import */ var _libs_nanoevents__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\nvar LOG = \'[ FxBase ]\';\nvar DEBUG = true;\n\nvar _default =\n/*#__PURE__*/\nfunction (_NanoEvents) {\n  _inherits(_default, _NanoEvents);\n\n  function _default(element, options) {\n    var _this;\n\n    _classCallCheck(this, _default);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(_default).call(this));\n    _this.manifest = _this.constructor.manifest;\n    _this.element = element;\n    _this.options = options || {};\n    return _this;\n  }\n\n  _createClass(_default, [{\n    key: "init",\n    value: function init() {\n      this.options = Object.assign({}, this.manifest.options, this.options);\n      this.init();\n    }\n  }, {\n    key: "update",\n    value: function update() {}\n  }, {\n    key: "start",\n    value: function start() {}\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(_libs_nanoevents__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9meC9GeEJhc2UuanM/OGRlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuaW1wb3J0IE5hbm9FdmVudHMgZnJvbSAnLi4vLi4vbGlicy9uYW5vZXZlbnRzJztcbnZhciBMT0cgPSAnWyBGeEJhc2UgXSc7XG52YXIgREVCVUcgPSB0cnVlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9OYW5vRXZlbnRzKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX05hbm9FdmVudHMpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmNhbGwodGhpcykpO1xuICAgIF90aGlzLm1hbmlmZXN0ID0gX3RoaXMuY29uc3RydWN0b3IubWFuaWZlc3Q7XG4gICAgX3RoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm1hbmlmZXN0Lm9wdGlvbnMsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcImVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQoKSB7fVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufShOYW5vRXZlbnRzKTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _default; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Nano Events\n * Taken from https://github.com/ai/nanoevents (MIT license)\n */\nvar _default =\n/*#__PURE__*/\nfunction () {\n  function _default() {\n    _classCallCheck(this, _default);\n\n    _defineProperty(this, "events", {});\n  }\n  /**\n   * Calls each of the listeners registered for a given event.\n   *\n   * @param {string} event The event name.\n   * @param {...*} arguments The arguments for listeners.\n   *\n   * @return {undefined}\n   *\n   * @example\n   * ee.emit(\'tick\', tickType, tickDuration)\n   *\n   * @alias NanoEvents#emit\n   * @method\n   */\n\n\n  _createClass(_default, [{\n    key: "emit",\n    value: function emit(event) {\n      var args = [].slice.call(arguments, 1) // Array.prototype.call() returns empty array if context is not array-like\n      ;\n      [].slice.call(this.events[event] || []).filter(function (i) {\n        i.apply(null, args);\n      });\n    }\n    /**\n     * Add a listener for a given event.\n     *\n     * @param {string} event The event name.\n     * @param {function} cb The listener function.\n     *\n     * @return {function} Unbind listener from event.\n     *\n     * @example\n     * const unbind = ee.on(\'tick\', (tickType, tickDuration) => {\n     *   count += 1\n     * })\n     *\n     * disable () {\n     *   unbind()\n     * }\n     *\n     * @alias NanoEvents#on\n     * @method\n     */\n\n  }, {\n    key: "on",\n    value: function on(event, cb) {\n      if (false) {}\n\n      (this.events[event] = this.events[event] || []).push(cb);\n      return function () {\n        this.events[event] = this.events[event].filter(function (i) {\n          return i !== cb;\n        });\n      }.bind(this);\n    }\n    /**\n     * Removes all listeners.\n     *\n     * @returns {undefined}\n     *\n     * @example\n     * unbindAll(emitter)\n     */\n\n  }, {\n    key: "unbindAll",\n    value: function unbindAll() {\n      this.events = {};\n    }\n  }]);\n\n  return _default;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2xpYnMvbmFub2V2ZW50cy5qcz9kYTNiIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLyoqXG4gKiBOYW5vIEV2ZW50c1xuICogVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYWkvbmFub2V2ZW50cyAoTUlUIGxpY2Vuc2UpXG4gKi9cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJldmVudHNcIiwge30pO1xuICB9XG4gIC8qKlxuICAgKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cyBUaGUgYXJndW1lbnRzIGZvciBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogZWUuZW1pdCgndGljaycsIHRpY2tUeXBlLCB0aWNrRHVyYXRpb24pXG4gICAqXG4gICAqIEBhbGlhcyBOYW5vRXZlbnRzI2VtaXRcbiAgICogQG1ldGhvZFxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiZW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSAvLyBBcnJheS5wcm90b3R5cGUuY2FsbCgpIHJldHVybnMgZW1wdHkgYXJyYXkgaWYgY29udGV4dCBpcyBub3QgYXJyYXktbGlrZVxuICAgICAgO1xuICAgICAgW10uc2xpY2UuY2FsbCh0aGlzLmV2ZW50c1tldmVudF0gfHwgW10pLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICBpLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBVbmJpbmQgbGlzdGVuZXIgZnJvbSBldmVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgdW5iaW5kID0gZWUub24oJ3RpY2snLCAodGlja1R5cGUsIHRpY2tEdXJhdGlvbikgPT4ge1xuICAgICAqICAgY291bnQgKz0gMVxuICAgICAqIH0pXG4gICAgICpcbiAgICAgKiBkaXNhYmxlICgpIHtcbiAgICAgKiAgIHVuYmluZCgpXG4gICAgICogfVxuICAgICAqXG4gICAgICogQGFsaWFzIE5hbm9FdmVudHMjb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbihldmVudCwgY2IpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgfVxuXG4gICAgICAodGhpcy5ldmVudHNbZXZlbnRdID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdKS5wdXNoKGNiKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50XSA9IHRoaXMuZXZlbnRzW2V2ZW50XS5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gaSAhPT0gY2I7XG4gICAgICAgIH0pO1xuICAgICAgfS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB1bmJpbmRBbGwoZW1pdHRlcilcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVuYmluZEFsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRBbGwoKSB7XG4gICAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oKTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n')},function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n')},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = throttle;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gudGhyb3R0bGUvaW5kZXguanM/ODRhMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuICogaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgXG4gKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG4gKiB0aHJvdHRsZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmcuXG4gKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gKlxuICogLy8gSW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXMuXG4gKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG4gIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICB9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGU7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = debounce;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(2)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2Rhc2guZGVib3VuY2UvaW5kZXguanM/ZjdmZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVib3VuY2U7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _default; });\n/* harmony import */ var _FxBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n// SCAN FOR FX\n\nvar LOG = \'[ FxScanner ]\';\nvar DEBUG = false;\n\nvar _default =\n/*#__PURE__*/\nfunction () {\n  function _default() {\n    _classCallCheck(this, _default);\n  }\n\n  _createClass(_default, null, [{\n    key: "scan",\n    value: function scan(context) {\n      if (context instanceof Element) {\n        this._scanElement(context);\n      }\n    }\n  }, {\n    key: "_scanElement",\n    value: function _scanElement(element) {\n      var _this = this;\n\n      Object.keys(mojo.fx).forEach(function (item) {\n        if (mojo.fx[item].prototype instanceof _FxBase__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]) {\n          _this._processFx(element, item);\n        }\n      });\n    }\n  }, {\n    key: "_processFx",\n    value: function _processFx(element, fx) {\n      var attr = "mojo-fx-".concat(mojo.fx[fx].manifest.id);\n      var elements = element.querySelectorAll("[".concat(attr, "]"));\n\n      for (var i = 0; i < elements.length; i++) {\n        var _element = elements[i];\n        if (_element.mojo && _element.mojo.scanned) continue;\n        ;\n        var options = this.extractOptions(_element.getAttribute(attr));\n        var trigger = options.trigger || mojo.fx[fx].manifest.options.trigger || \'click\';\n        mojo.add(_element, trigger, mojo.fx[fx], options);\n        mojo.prepareElement(_element);\n        _element.mojo.scanned = true;\n      }\n    }\n  }, {\n    key: "extractOptions",\n    value: function extractOptions(raw) {\n      if (!raw) return {}; // Eval solution\n\n      return eval("(function() { return ".concat(raw, "})()")); // Primitive version (only support flat non-nested values, no arrays , no objects)\n      // raw = raw.replace(/{(.*)}/, \'$1\');\n      // let args = raw.split(\',\').map( (item) => item.trim().split(\':\') );\n      // let result = {};\n      // args.forEach(item => { \n      //   let val = item[1].trim();\n      //   if (!isNaN(val)) { val = +val; }\n      //   else if (val.indexOf("\'") == 0) { val = val.replace(/\'/g, \'\'); }\n      //   else if (val == \'true\') { val = true; }\n      //   else if (val == \'false\') { val = false; }\n      //   result[item[0].trim()] = val; \n      // });\n      // return result;\n    }\n  }]);\n\n  return _default;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9meC9GeFNjYW5uZXIuanM/NGI4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbi8vIFNDQU4gRk9SIEZYXG5pbXBvcnQgRnhCYXNlIGZyb20gJy4vRnhCYXNlJztcbnZhciBMT0cgPSAnWyBGeFNjYW5uZXIgXSc7XG52YXIgREVCVUcgPSBmYWxzZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgbnVsbCwgW3tcbiAgICBrZXk6IFwic2NhblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY2FuKGNvbnRleHQpIHtcbiAgICAgIGlmIChjb250ZXh0IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICB0aGlzLl9zY2FuRWxlbWVudChjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NjYW5FbGVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zY2FuRWxlbWVudChlbGVtZW50KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBPYmplY3Qua2V5cyhtb2pvLmZ4KS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChtb2pvLmZ4W2l0ZW1dLnByb3RvdHlwZSBpbnN0YW5jZW9mIEZ4QmFzZSkge1xuICAgICAgICAgIF90aGlzLl9wcm9jZXNzRngoZWxlbWVudCwgaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcHJvY2Vzc0Z4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wcm9jZXNzRngoZWxlbWVudCwgZngpIHtcbiAgICAgIHZhciBhdHRyID0gXCJtb2pvLWZ4LVwiLmNvbmNhdChtb2pvLmZ4W2Z4XS5tYW5pZmVzdC5pZCk7XG4gICAgICB2YXIgZWxlbWVudHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbXCIuY29uY2F0KGF0dHIsIFwiXVwiKSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIF9lbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgIGlmIChfZWxlbWVudC5tb2pvICYmIF9lbGVtZW50Lm1vam8uc2Nhbm5lZCkgY29udGludWU7XG4gICAgICAgIDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmV4dHJhY3RPcHRpb25zKF9lbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyKSk7XG4gICAgICAgIHZhciB0cmlnZ2VyID0gb3B0aW9ucy50cmlnZ2VyIHx8IG1vam8uZnhbZnhdLm1hbmlmZXN0Lm9wdGlvbnMudHJpZ2dlciB8fCAnY2xpY2snO1xuICAgICAgICBtb2pvLmFkZChfZWxlbWVudCwgdHJpZ2dlciwgbW9qby5meFtmeF0sIG9wdGlvbnMpO1xuICAgICAgICBtb2pvLnByZXBhcmVFbGVtZW50KF9lbGVtZW50KTtcbiAgICAgICAgX2VsZW1lbnQubW9qby5zY2FubmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXh0cmFjdE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0cmFjdE9wdGlvbnMocmF3KSB7XG4gICAgICBpZiAoIXJhdykgcmV0dXJuIHt9OyAvLyBFdmFsIHNvbHV0aW9uXG5cbiAgICAgIHJldHVybiBldmFsKFwiKGZ1bmN0aW9uKCkgeyByZXR1cm4gXCIuY29uY2F0KHJhdywgXCJ9KSgpXCIpKTsgLy8gUHJpbWl0aXZlIHZlcnNpb24gKG9ubHkgc3VwcG9ydCBmbGF0IG5vbi1uZXN0ZWQgdmFsdWVzLCBubyBhcnJheXMgLCBubyBvYmplY3RzKVxuICAgICAgLy8gcmF3ID0gcmF3LnJlcGxhY2UoL3soLiopfS8sICckMScpO1xuICAgICAgLy8gbGV0IGFyZ3MgPSByYXcuc3BsaXQoJywnKS5tYXAoIChpdGVtKSA9PiBpdGVtLnRyaW0oKS5zcGxpdCgnOicpICk7XG4gICAgICAvLyBsZXQgcmVzdWx0ID0ge307XG4gICAgICAvLyBhcmdzLmZvckVhY2goaXRlbSA9PiB7IFxuICAgICAgLy8gICBsZXQgdmFsID0gaXRlbVsxXS50cmltKCk7XG4gICAgICAvLyAgIGlmICghaXNOYU4odmFsKSkgeyB2YWwgPSArdmFsOyB9XG4gICAgICAvLyAgIGVsc2UgaWYgKHZhbC5pbmRleE9mKFwiJ1wiKSA9PSAwKSB7IHZhbCA9IHZhbC5yZXBsYWNlKC8nL2csICcnKTsgfVxuICAgICAgLy8gICBlbHNlIGlmICh2YWwgPT0gJ3RydWUnKSB7IHZhbCA9IHRydWU7IH1cbiAgICAgIC8vICAgZWxzZSBpZiAodmFsID09ICdmYWxzZScpIHsgdmFsID0gZmFsc2U7IH1cbiAgICAgIC8vICAgcmVzdWx0W2l0ZW1bMF0udHJpbSgpXSA9IHZhbDsgXG4gICAgICAvLyB9KTtcbiAgICAgIC8vIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufSgpO1xuXG5leHBvcnQgeyBfZGVmYXVsdCBhcyBkZWZhdWx0IH07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n')},function(module,exports,__webpack_require__){eval("var content = __webpack_require__(7);\n\nif (typeof content === 'string') {\n  content = [[module.i, content, '']];\n}\n\nvar options = {}\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = __webpack_require__(9)(content, options);\n\nif (content.locals) {\n  module.exports = content.locals;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3N0eWxlL2Z1c2lvbi5zY3NzPzhiZWEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9mdXNpb24uc2Nzc1wiKTtcblxuaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG59XG5cbnZhciBvcHRpb25zID0ge31cblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYgKGNvbnRlbnQubG9jYWxzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(8)(false);\n// Module\nexports.push([module.i, ".fusion--player{display:flex;justify-content:center}.fusion--player .fusion--viewport{position:relative;width:100%;height:100%}.fusion--player .fusion--viewport .fusion--scene{position:absolute;top:0;right:0;bottom:0;left:0;overflow-x:hidden;overflow-y:hidden}.fusion--player .fusion--viewport .fusion--scene.fusion--scene--iframe iframe.fusion--iframe{overflow:hidden;border:none}.fusion--player .fusion--viewport .fusion--scene .fusion--scene--content{position:absolute;top:0;right:0;bottom:0;left:0;transform-origin:top left;overflow:hidden}.fusion--player .fusion--viewport .fusion--scene .fusion--scene--content>*{width:100%;height:100%}.fusion--player .fusion--viewport .fusion--scene .fusion--scene--content>*>*{position:absolute;top:0;left:0}.fusion--player .fusion--viewport .fusion--scene--debugger--guidesWrapper{position:absolute;top:0;right:0;bottom:0;left:0;z-index:9999999;pointer-events:none}.fusion--player .fusion--viewport .fusion--scene--debugger--guidesWrapper .guide-horizontal-center{position:absolute;top:0;bottom:0;left:50%;width:1px;z-index:99999;border-left:1px dashed rgba(0,0,0,0.8)}.fusion--player .fusion--viewport .fusion--scene--debugger--guidesWrapper .guide-sceneBounds{position:absolute;top:0;right:0;bottom:0;left:0;transform-origin:top left;background-color:rgba(108,159,255,0.3)}\\n", ""]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3N0eWxlL2Z1c2lvbi5zY3NzPzk4MWQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIikoZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuZnVzaW9uLS1wbGF5ZXJ7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXJ9LmZ1c2lvbi0tcGxheWVyIC5mdXNpb24tLXZpZXdwb3J0e3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCV9LmZ1c2lvbi0tcGxheWVyIC5mdXNpb24tLXZpZXdwb3J0IC5mdXNpb24tLXNjZW5le3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowO292ZXJmbG93LXg6aGlkZGVuO292ZXJmbG93LXk6aGlkZGVufS5mdXNpb24tLXBsYXllciAuZnVzaW9uLS12aWV3cG9ydCAuZnVzaW9uLS1zY2VuZS5mdXNpb24tLXNjZW5lLS1pZnJhbWUgaWZyYW1lLmZ1c2lvbi0taWZyYW1le292ZXJmbG93OmhpZGRlbjtib3JkZXI6bm9uZX0uZnVzaW9uLS1wbGF5ZXIgLmZ1c2lvbi0tdmlld3BvcnQgLmZ1c2lvbi0tc2NlbmUgLmZ1c2lvbi0tc2NlbmUtLWNvbnRlbnR7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjA7dHJhbnNmb3JtLW9yaWdpbjp0b3AgbGVmdDtvdmVyZmxvdzpoaWRkZW59LmZ1c2lvbi0tcGxheWVyIC5mdXNpb24tLXZpZXdwb3J0IC5mdXNpb24tLXNjZW5lIC5mdXNpb24tLXNjZW5lLS1jb250ZW50Pip7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJX0uZnVzaW9uLS1wbGF5ZXIgLmZ1c2lvbi0tdmlld3BvcnQgLmZ1c2lvbi0tc2NlbmUgLmZ1c2lvbi0tc2NlbmUtLWNvbnRlbnQ+Kj4qe3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MH0uZnVzaW9uLS1wbGF5ZXIgLmZ1c2lvbi0tdmlld3BvcnQgLmZ1c2lvbi0tc2NlbmUtLWRlYnVnZ2VyLS1ndWlkZXNXcmFwcGVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowO3otaW5kZXg6OTk5OTk5OTtwb2ludGVyLWV2ZW50czpub25lfS5mdXNpb24tLXBsYXllciAuZnVzaW9uLS12aWV3cG9ydCAuZnVzaW9uLS1zY2VuZS0tZGVidWdnZXItLWd1aWRlc1dyYXBwZXIgLmd1aWRlLWhvcml6b250YWwtY2VudGVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2JvdHRvbTowO2xlZnQ6NTAlO3dpZHRoOjFweDt6LWluZGV4Ojk5OTk5O2JvcmRlci1sZWZ0OjFweCBkYXNoZWQgcmdiYSgwLDAsMCwwLjgpfS5mdXNpb24tLXBsYXllciAuZnVzaW9uLS12aWV3cG9ydCAuZnVzaW9uLS1zY2VuZS0tZGVidWdnZXItLWd1aWRlc1dyYXBwZXIgLmd1aWRlLXNjZW5lQm91bmRze3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowO3RyYW5zZm9ybS1vcmlnaW46dG9wIGxlZnQ7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDEwOCwxNTksMjU1LDAuMyl9XFxuXCIsIFwiXCJdKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return "@media ".concat(item[2], "{").concat(content, "}");\n      }\n\n      return content;\n    }).join(\'\');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === \'string\') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \'\']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      // eslint-disable-next-line prefer-destructuring\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = modules[_i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = "(".concat(item[2], ") and (").concat(mediaQuery, ")");\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || \'\'; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === \'function\') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return "/*# sourceURL=".concat(cssMapping.sourceRoot).concat(source, " */");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join(\'\\n\');\n  }\n\n  return [content].join(\'\\n\');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\n  return "/*# ".concat(data, " */");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanM/MjRmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXNlU291cmNlTWFwKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIntcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbignJyk7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgJyddXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBpdGVtID0gbW9kdWxlc1tfaV07IC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcbiAgICAgIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG4gICAgICAvLyB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG4gICAgICAvLyBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cbiAgICAgIGlmIChpdGVtWzBdID09IG51bGwgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgaWYgKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgICAgaXRlbVsyXSA9IFwiKFwiLmNvbmNhdChpdGVtWzJdLCBcIikgYW5kIChcIikuY29uY2F0KG1lZGlhUXVlcnksIFwiKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuXG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290KS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcblxuXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICByZXR1cm4gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xufSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar stylesInDom = {};\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nfunction listToStyles(list, options) {\n  var styles = [];\n  var newStyles = {};\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var css = item[1];\n    var media = item[2];\n    var sourceMap = item[3];\n    var part = {\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    };\n\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = {\n        id: id,\n        parts: [part]\n      });\n    } else {\n      newStyles[id].parts.push(part);\n    }\n  }\n\n  return styles;\n}\n\nfunction addStylesToDom(styles, options) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i];\n    var domStyle = stylesInDom[item.id];\n    var j = 0;\n\n    if (domStyle) {\n      domStyle.refs++;\n\n      for (; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j]);\n      }\n\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j], options));\n      }\n    } else {\n      var parts = [];\n\n      for (; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j], options));\n      }\n\n      stylesInDom[item.id] = {\n        id: item.id,\n        refs: 1,\n        parts: parts\n      };\n    }\n  }\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n\n  if (typeof options.attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : undefined;\n\n    if (nonce) {\n      options.attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(options.attributes).forEach(function (key) {\n    style.setAttribute(key, options.attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  }\n\n  if (sourceMap && btoa) {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  options.attributes = typeof options.attributes === 'object' ? options.attributes : {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  var styles = listToStyles(list, options);\n  addStylesToDom(styles, options);\n  return function update(newList) {\n    var mayRemove = [];\n\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i];\n      var domStyle = stylesInDom[item.id];\n\n      if (domStyle) {\n        domStyle.refs--;\n        mayRemove.push(domStyle);\n      }\n    }\n\n    if (newList) {\n      var newStyles = listToStyles(newList, options);\n      addStylesToDom(newStyles, options);\n    }\n\n    for (var _i = 0; _i < mayRemove.length; _i++) {\n      var _domStyle = mayRemove[_i];\n\n      if (_domStyle.refs === 0) {\n        for (var j = 0; j < _domStyle.parts.length; j++) {\n          _domStyle.parts[j]();\n        }\n\n        delete stylesInDom[_domStyle.id];\n      }\n    }\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcz8yZGJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyIGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICB2YXIgbWVtbztcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufSgpO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICB2YXIgbWVtbyA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZXMgPSBbXTtcbiAgdmFyIG5ld1N0eWxlcyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY3NzID0gaXRlbVsxXTtcbiAgICB2YXIgbWVkaWEgPSBpdGVtWzJdO1xuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuICAgIHZhciBwYXJ0ID0ge1xuICAgICAgY3NzOiBjc3MsXG4gICAgICBtZWRpYTogbWVkaWEsXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxuICAgIH07XG5cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgcGFydHM6IFtwYXJ0XVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXTtcbiAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcbiAgICB2YXIgaiA9IDA7XG5cbiAgICBpZiAoZG9tU3R5bGUpIHtcbiAgICAgIGRvbVN0eWxlLnJlZnMrKztcblxuICAgICAgZm9yICg7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgICAgZm9yICg7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuICAgICAgfVxuXG4gICAgICBzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtcbiAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgIHJlZnM6IDEsXG4gICAgICAgIHBhcnRzOiBwYXJ0c1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBvcHRpb25zLmF0dHJpYnV0ZXMubm9uY2UgPSBub25jZTtcbiAgICB9XG4gIH1cblxuICBPYmplY3Qua2V5cyhvcHRpb25zLmF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIG9wdGlvbnMuYXR0cmlidXRlc1trZXldKTtcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG52YXIgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmouY3NzOyAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzcztcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCAmJiBidG9hKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMDtcblxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZTtcbiAgdmFyIHVwZGF0ZTtcbiAgdmFyIHJlbW92ZTtcblxuICBpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcbiAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cbiAgICByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUob2JqKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmF0dHJpYnV0ZXMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRyaWJ1dGVzID09PSAnb2JqZWN0JyA/IG9wdGlvbnMuYXR0cmlidXRlcyA6IHt9OyAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXG4gIGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSAnYm9vbGVhbicpIHtcbiAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgfVxuXG4gIHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG4gIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xuICAgIHZhciBtYXlSZW1vdmUgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXTtcbiAgICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG4gICAgICBpZiAoZG9tU3R5bGUpIHtcbiAgICAgICAgZG9tU3R5bGUucmVmcy0tO1xuICAgICAgICBtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5ld0xpc3QpIHtcbiAgICAgIHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG4gICAgICBhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtYXlSZW1vdmUubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2RvbVN0eWxlID0gbWF5UmVtb3ZlW19pXTtcblxuICAgICAgaWYgKF9kb21TdHlsZS5yZWZzID09PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgX2RvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgX2RvbVN0eWxlLnBhcnRzW2pdKCk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgc3R5bGVzSW5Eb21bX2RvbVN0eWxlLmlkXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/lodash.throttle/index.js\nvar lodash_throttle = __webpack_require__(3);\nvar lodash_throttle_default = /*#__PURE__*/__webpack_require__.n(lodash_throttle);\n\n// EXTERNAL MODULE: ./node_modules/lodash.debounce/index.js\nvar lodash_debounce = __webpack_require__(4);\nvar lodash_debounce_default = /*#__PURE__*/__webpack_require__.n(lodash_debounce);\n\n// CONCATENATED MODULE: ./src/core/Brain.js\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar LOG = \'[ Brain ]\';\nvar DEBUG = true;\n\nvar Brain_default =\n/*#__PURE__*/\nfunction () {\n  function _default() {\n    _classCallCheck(this, _default);\n\n    DEBUG && console.log(LOG, \'constructor()\');\n  }\n\n  _createClass(_default, [{\n    key: "add",\n    value: function add(p) {\n      console.log(LOG, \'add() p:\', p);\n    }\n  }]);\n\n  return _default;\n}();\n\n\n// EXTERNAL MODULE: ./src/fx/FxBase.js\nvar FxBase = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/core/Mojo.js\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction Mojo_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Mojo_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Mojo_createClass(Constructor, protoProps, staticProps) { if (protoProps) Mojo_defineProperties(Constructor.prototype, protoProps); if (staticProps) Mojo_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\nvar Mojo_LOG = \'[ Mojo ]\';\nvar Mojo_DEBUG = false;\n\nvar Mojo_default =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Constructor\n   */\n  function _default() {\n    Mojo_classCallCheck(this, _default);\n\n    _defineProperty(this, "brain", void 0);\n\n    this.brain = new Brain_default();\n    Mojo_DEBUG && console.log(Mojo_LOG, \'constructor()\');\n  }\n  /**\n   * Add\n   * For parameters also see addBehavior()\n   */\n\n\n  Mojo_createClass(_default, [{\n    key: "add",\n    value: function add() {\n      // Delegate depending on signature\n      if (arguments[0] instanceof Element && (typeof arguments[1] === \'string\' || _typeof(arguments[1]) === \'object\' && typeof arguments[1].type === \'string\') && arguments[2].prototype instanceof mojo.fx.FxBase) {\n        this.addBehavior.apply(this, arguments);\n      }\n    }\n    /**\n     * Add behavior\n     * (supports automatic area detection: if next node has attribute "mojo-trigger-area" )\n     * @param {HTMLElement} el The host element to add the behavior to\n     * @param {(string|object)} trigger The trigger type (e.g. click, hover, toggle etc.)\n     *                                  E.g. \'click\' or {type: \'hover\', area: \'#custom-trigger-area\'}\n     * @param {FxBase} Fx The effect class to apply (e.g. mojo.fx.Magnet)\n     * @param {object} [fxOptions] Optional effect options (e.g {speed: 2})\n     */\n\n  }, {\n    key: "addBehavior",\n    value: function addBehavior(el, trigger, Fx, fxOptions) {\n      Mojo_DEBUG && console.log(Mojo_LOG, \'addBehavior()\', el, trigger);\n      var triggerType = typeof trigger === \'string\' ? trigger : trigger.type,\n          // area = (typeof(trigger) === \'string\') ? el : (typeof(trigger.area) === \'string\') ? document.querySelector(trigger.area) : trigger.area,\n      standard = true,\n          startTrigger,\n          endTrigger; //---\n      // Create fx\n\n      fxOptions = fxOptions ? fxOptions : {};\n      var fx = new Fx(el, fxOptions);\n      el = fx.element; //---\n      // Area\n\n      var area = typeof trigger === \'string\' ? el : typeof trigger.area === \'string\' ? document.querySelector(trigger.area) : trigger.area;\n\n      if (area == el) {\n        // Auto detect area (next node has "mojo-trigger-area" attribute)\n        if (el.nextElementSibling && el.nextElementSibling.hasAttribute(\'mojo-trigger-area\')) {\n          if (el.nextElementSibling.tagName == \'svg\') {\n            area = el.nextElementSibling.firstChild;\n            el.nextElementSibling.style.pointerEvents = \'none\';\n          } else {\n            area = el.nextElementSibling;\n          }\n\n          el.style.pointerEvents = \'none\';\n        }\n      } //---\n      // Trigger type\n\n\n      switch (triggerType) {\n        case \'\':\n        case \'auto\':\n          standard = false;\n          break;\n\n        case \'click\':\n          startTrigger = \'click\';\n          break;\n\n        case \'hover\':\n          startTrigger = \'mouseenter\';\n          endTrigger = \'mouseleave\';\n          break;\n\n        case \'toggle\':\n          startTrigger = \'click\';\n          endTrigger = \'click\';\n          standard = false;\n          break;\n      } //---\n      // Setup triggering (event listeners etc.)\n\n\n      if (standard) {\n        startTrigger && area.addEventListener(startTrigger, fx.start.bind(fx));\n        endTrigger && area.addEventListener(endTrigger, fx.end.bind(fx));\n      } else {\n        switch (triggerType) {\n          case \'\':\n          case \'auto\':\n            fx.start();\n            break;\n\n          case \'toggle\':\n            var on = true;\n            area.addEventListener(\'click\', function (evt) {\n              on ? fx.start() : fx.end();\n              on = !on;\n            });\n            break;\n        }\n      } //---\n      // Memorize on element level if fx has id\n\n\n      if (fxOptions.id) {\n        console.log(\'Memorize on element with id:\', fxOptions.id);\n        this.prepareElement(el);\n        el.mojo.fx.push(fx);\n      }\n    }\n    /**\n     * Prepare element\n     */\n\n  }, {\n    key: "prepareElement",\n    value: function prepareElement(el) {\n      !el.mojo && (el.mojo = {\n        fx: []\n      });\n    }\n  }]);\n\n  return _default;\n}();\n\n\n// CONCATENATED MODULE: ./src/core/FusionHelper.js\nfunction FusionHelper_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction FusionHelper_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction FusionHelper_createClass(Constructor, protoProps, staticProps) { if (protoProps) FusionHelper_defineProperties(Constructor.prototype, protoProps); if (staticProps) FusionHelper_defineProperties(Constructor, staticProps); return Constructor; }\n\nvar FusionHelper =\n/*#__PURE__*/\nfunction () {\n  function FusionHelper() {\n    FusionHelper_classCallCheck(this, FusionHelper);\n  }\n\n  FusionHelper_createClass(FusionHelper, null, [{\n    key: "appendHtml",\n    value: function appendHtml(target, markup) {\n      target.insertAdjacentHTML(\'beforeend\', markup);\n      return target.lastChild;\n    } //---\n    // DEPRECATED !!!! (use mojo.helper.throttle etc.)\n    // https://github.com/m-gagne/limit.js\n    // (slightly modified)\n\n  }, {\n    key: "debounce",\n    value: function debounce(func, milliseconds, context) {\n      var baseFunction = func,\n          timer = null,\n          wait = milliseconds;\n      return function () {\n        var self = context || func,\n            args = arguments;\n\n        function complete() {\n          baseFunction.apply(self, args);\n          timer = null;\n        }\n\n        if (timer) {\n          clearTimeout(timer);\n        }\n\n        timer = setTimeout(complete, wait);\n      };\n    } //---\n    // DEPRECATED !!!! (use mojo.helper.throttle etc.)\n    // https://github.com/m-gagne/limit.js\n    // (slightly modified)\n\n  }, {\n    key: "throttle",\n    value: function throttle(func, milliseconds, context) {\n      var baseFunction = func,\n          lastEventTimestamp = null,\n          limit = milliseconds,\n          timeout,\n          lastCurrentTarget;\n      return function () {\n        var self = context || func,\n            args = arguments,\n            now = Date.now();\n\n        if (!lastEventTimestamp || now - lastEventTimestamp >= limit) {\n          lastEventTimestamp = now;\n          baseFunction.apply(self, args);\n\n          if (args[0] instanceof Event) {\n            lastCurrentTarget = args[0].currentTarget;\n          }\n        } else {\n          if (timeout) {\n            clearTimeout(timeout);\n            timeout = undefined;\n          }\n\n          if (args[0] instanceof Event) {\n            args[0].currentTarget_ = lastCurrentTarget;\n          }\n\n          timeout = setTimeout(function () {\n            baseFunction.apply(self, args);\n          }, milliseconds);\n        }\n      };\n    }\n    /*!\n     * Check if an element is inside the viewport\n     * #TODO Consider:\n     *   + caching\n     *   + partially in viewport\n     *   + not relative to window but to parent container\n     * #PERFORMANCE getBoundingClientRect() might become a performance bottleneck\n     *              see https://gist.github.com/paulirish/5d52fb081b3570c81e3a\n     *              and https://github.com/pelotoncycle/resize-observer/issues/5\n     * @param  {Node} el The element\n     * @return {Boolean} Returns true if element is in the viewport\n     */\n\n  }, {\n    key: "isInViewport",\n    value: function isInViewport(el) {\n      var distance = el.getBoundingClientRect();\n      return distance.top >= 0 && distance.left >= 0 && distance.bottom <= (window.innerHeight || document.documentElement.clientHeight) && distance.right <= (window.innerWidth || document.documentElement.clientWidth);\n    }\n  }]);\n\n  return FusionHelper;\n}();\n// CONCATENATED MODULE: ./src/Const.js\n/* harmony default export */ var Const = ({\n  SCENE_PLUGINS_READY: \'SCENE_PLUGINS_READY\',\n  SCENE_PRE_READY: \'SCENE_PRE_READY\',\n  SCENE_READY: \'SCENE_READY\'\n});\n// CONCATENATED MODULE: ./src/core/FusionSceneDebugger.js\nfunction FusionSceneDebugger_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction FusionSceneDebugger_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction FusionSceneDebugger_createClass(Constructor, protoProps, staticProps) { if (protoProps) FusionSceneDebugger_defineProperties(Constructor.prototype, protoProps); if (staticProps) FusionSceneDebugger_defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar FusionSceneDebugger_LOG = \'[ FusionSceneDebugger ]\';\n\nvar FusionSceneDebugger_default =\n/*#__PURE__*/\nfunction () {\n  function _default(scene) {\n    var _this = this;\n\n    FusionSceneDebugger_classCallCheck(this, _default);\n\n    this.scene = scene;\n    console.log(FusionSceneDebugger_LOG, \'constructor()\', scene);\n    scene.on(Const.SCENE_PRE_READY, function () {\n      _this.guidesWrapper = FusionHelper.appendHtml(scene.element.parentNode, "<div class=\\"fusion--scene--debugger--guidesWrapper\\"></div>");\n      ;\n      _this.guideHorizontalCenter = FusionHelper.appendHtml(_this.guidesWrapper, "<div class=\\"guide-horizontal-center\\"></div>");\n      ;\n      _this.guideSceneBounds = FusionHelper.appendHtml(_this.guidesWrapper, "<div class=\\"guide-sceneBounds\\"></div>");\n      ;\n    });\n    scene.on(Const.SCENE_READY, function () {\n      setTimeout(function () {\n        _this.size();\n\n        if (scene.center != false && !scene.fit) {\n          window.addEventListener(\'resize\', FusionHelper.debounce(_this.center.bind(_this), 50));\n\n          _this.center();\n        }\n\n        if (scene.fit != false) {\n          window.addEventListener(\'resize\', FusionHelper.debounce(_this.fit.bind(_this), 50));\n\n          _this.fit();\n        }\n      }, 200);\n    });\n  }\n  /**\n   * Size\n   */\n\n\n  FusionSceneDebugger_createClass(_default, [{\n    key: "size",\n    value: function size() {\n      this.guideSceneBounds.style.width = typeof this.scene.width == \'string\' ? this.scene.width : "".concat(this.scene.width, "px");\n      this.guideSceneBounds.style.height = typeof this.scene.height == \'string\' ? this.scene.height : "".concat(this.scene.height, "px");\n      this.scene.data.maxWidth && (this.guideSceneBounds.style.maxWidth = "".concat(this.scene.maxWidth, "px"));\n      this.scene.data.maxHeight && (this.guideSceneBounds.style.maxHeight = "".concat(this.scene.maxHeight, "px"));\n    }\n    /**\n     * Center guideSceneBounds\n     */\n\n  }, {\n    key: "center",\n    value: function center() {\n      this.guideSceneBounds.style.left = \'50%\';\n      this.guideSceneBounds.style.top = \'50%\';\n      this.guideSceneBounds.style.marginLeft = "-".concat(this.scene.width * this.scene.scale / 2, "px");\n      this.guideSceneBounds.style.marginTop = "-".concat(this.scene.height * this.scene.scale / 2, "px");\n    }\n    /**\n     * fit guideSceneBounds (responsive scaling)\n     */\n\n  }, {\n    key: "fit",\n    value: function fit() {\n      var availableWidth = this.scene.player.viewport.clientWidth;\n      var availableHeight = this.scene.player.viewport.clientHeight;\n      this.scene.scale = Math.min(availableWidth / this.scene.width, availableHeight / this.scene.height);\n      this.scene.scale = this.scene.scale > 1 ? 1 : this.scene.scale;\n      this.guideSceneBounds.style.transform = "scale(".concat(this.scene.scale, ")");\n      this.center();\n    }\n  }]);\n\n  return _default;\n}();\n\n\n// EXTERNAL MODULE: ./libs/nanoevents.js\nvar nanoevents = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/core/FusionScene.js\nfunction FusionScene_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { FusionScene_typeof = function _typeof(obj) { return typeof obj; }; } else { FusionScene_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return FusionScene_typeof(obj); }\n\nfunction FusionScene_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction FusionScene_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction FusionScene_createClass(Constructor, protoProps, staticProps) { if (protoProps) FusionScene_defineProperties(Constructor.prototype, protoProps); if (staticProps) FusionScene_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (FusionScene_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\nvar FusionScene_LOG = \'[ FusionScene ]\';\nvar FusionScene_DEBUG = true;\n\nvar FusionScene_default =\n/*#__PURE__*/\nfunction (_NanoEvents) {\n  _inherits(_default, _NanoEvents);\n\n  function _default(player, data) {\n    var _this;\n\n    FusionScene_classCallCheck(this, _default);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(_default).call(this));\n    _this.player = player;\n    _this.element;\n    _this.content;\n    _this.data = data;\n    _this.id = data.id;\n    _this.width = data.width;\n    _this.height = data.height; // Debugger\n\n    if (_this.player.options.debug) {\n      _this["debugger"] = new FusionSceneDebugger_default(_assertThisInitialized(_this));\n    } // Plugins\n\n\n    _this.initPlugins();\n\n    _this.emit(Const.SCENE_PLUGINS_READY); // Preready\n\n\n    _this.on(Const.SCENE_PRE_READY, function () {\n      _this.size();\n\n      if (_this.data.center != false && !_this.data.fit) {\n        window.addEventListener(\'resize\', FusionHelper.debounce(_this.center.bind(_assertThisInitialized(_this)), 50));\n\n        _this.center();\n      }\n\n      if (_this.data.fit != false) {\n        window.addEventListener(\'resize\', FusionHelper.debounce(_this.fit.bind(_assertThisInitialized(_this)), 50));\n\n        _this.fit();\n      }\n\n      _this.emit(Const.SCENE_READY);\n    });\n\n    return _this;\n  }\n  /**\n   * Size\n   */\n\n\n  FusionScene_createClass(_default, [{\n    key: "size",\n    value: function size() {\n      this.content.style.width = typeof this.data.width == \'string\' ? this.data.width : "".concat(this.data.width, "px");\n      this.content.style.height = typeof this.data.height == \'string\' ? this.data.height : "".concat(this.data.height, "px");\n      this.data.maxWidth && (this.content.style.maxWidth = "".concat(this.data.maxWidth, "px"));\n      this.data.maxHeight && (this.content.style.maxHeight = "".concat(this.data.maxHeight, "px"));\n    }\n    /**\n     * Center content\n     */\n\n  }, {\n    key: "center",\n    value: function center() {\n      this.content.style.left = \'50%\';\n      this.content.style.top = \'50%\';\n      this.content.style.marginLeft = "-".concat(this.data.width * this.scale / 2, "px");\n      this.content.style.marginTop = "-".concat(this.data.height * this.scale / 2, "px");\n    }\n    /**\n     * fit content (responsive scaling)\n     */\n\n  }, {\n    key: "fit",\n    value: function fit() {\n      var availableWidth = this.player.viewport.clientWidth;\n      var availableHeight = this.player.viewport.clientHeight;\n      this.scale = Math.min(availableWidth / this.data.width, availableHeight / this.data.height);\n      this.scale = this.scale > 1 ? 1 : this.scale;\n      this.content.style.transform = "scale(".concat(this.scale, ")");\n      this.center();\n    }\n    /**\n     * Init plugins\n     */\n\n  }, {\n    key: "initPlugins",\n    value: function initPlugins() {\n      var _this2 = this;\n\n      // DEBUG && console.log(LOG, \'initPlugins(), plugins:\', this.data.plugins);\n      if (!this.data.plugins) return;\n      this.data.plugins.forEach(function (plugin) {\n        for (var key in mojo.plugins) {\n          if (plugin.id == mojo.plugins[key].manifest().id) {\n            new mojo.plugins[key](_this2, plugin.options);\n          }\n        }\n      });\n    }\n  }]);\n\n  return _default;\n}(nanoevents["a" /* default */]);\n\n\n// CONCATENATED MODULE: ./src/core/FusionSceneIframe.js\nfunction FusionSceneIframe_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { FusionSceneIframe_typeof = function _typeof(obj) { return typeof obj; }; } else { FusionSceneIframe_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return FusionSceneIframe_typeof(obj); }\n\nfunction FusionSceneIframe_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction FusionSceneIframe_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction FusionSceneIframe_createClass(Constructor, protoProps, staticProps) { if (protoProps) FusionSceneIframe_defineProperties(Constructor.prototype, protoProps); if (staticProps) FusionSceneIframe_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction FusionSceneIframe_possibleConstructorReturn(self, call) { if (call && (FusionSceneIframe_typeof(call) === "object" || typeof call === "function")) { return call; } return FusionSceneIframe_assertThisInitialized(self); }\n\nfunction FusionSceneIframe_getPrototypeOf(o) { FusionSceneIframe_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return FusionSceneIframe_getPrototypeOf(o); }\n\nfunction FusionSceneIframe_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction FusionSceneIframe_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) FusionSceneIframe_setPrototypeOf(subClass, superClass); }\n\nfunction FusionSceneIframe_setPrototypeOf(o, p) { FusionSceneIframe_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return FusionSceneIframe_setPrototypeOf(o, p); }\n\nfunction FusionSceneIframe_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\nvar FusionSceneIframe_LOG = \'[ FusionSceneIframe ]\';\n\nvar FusionSceneIframe_default =\n/*#__PURE__*/\nfunction (_FusionScene) {\n  FusionSceneIframe_inherits(_default, _FusionScene);\n\n  function _default(player, data) {\n    var _this;\n\n    FusionSceneIframe_classCallCheck(this, _default);\n\n    _this = FusionSceneIframe_possibleConstructorReturn(this, FusionSceneIframe_getPrototypeOf(_default).call(this, player, data));\n\n    FusionSceneIframe_defineProperty(FusionSceneIframe_assertThisInitialized(_this), "iframe", void 0);\n\n    return _this;\n  }\n\n  FusionSceneIframe_createClass(_default, [{\n    key: "load",\n    value: function load() {\n      console.log(FusionSceneIframe_LOG, \'load()\');\n      this.render();\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      // Create Markup\n      this.element = FusionHelper.appendHtml(this.viewport, "<div class=\\"fusion--scene fusion--scene--iframe scene-".concat(this.id, "\\"></div>"));\n      this.iframe = FusionHelper.appendHtml(this.element, "<iframe class=\\"fusion--iframe\\" src=\\"".concat(this.data.path, "\\" frameborder=\\"0\\" allowTransparency=\\"true\\"></iframe>"));\n      FusionHelper.appendHtml(this.element, this.data.html); // Iframe Size\n\n      this.iframe.style.width = \'100%\';\n      this.iframe.style.height = \'100%\'; // Propagate preready\n\n      this.emit(Const.SCENE_PRE_READY);\n    }\n  }]);\n\n  return _default;\n}(FusionScene_default);\n\n\n// CONCATENATED MODULE: ./src/core/FusionSceneDefault.js\nfunction FusionSceneDefault_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { FusionSceneDefault_typeof = function _typeof(obj) { return typeof obj; }; } else { FusionSceneDefault_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return FusionSceneDefault_typeof(obj); }\n\nfunction FusionSceneDefault_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction FusionSceneDefault_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction FusionSceneDefault_createClass(Constructor, protoProps, staticProps) { if (protoProps) FusionSceneDefault_defineProperties(Constructor.prototype, protoProps); if (staticProps) FusionSceneDefault_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction FusionSceneDefault_possibleConstructorReturn(self, call) { if (call && (FusionSceneDefault_typeof(call) === "object" || typeof call === "function")) { return call; } return FusionSceneDefault_assertThisInitialized(self); }\n\nfunction FusionSceneDefault_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction FusionSceneDefault_getPrototypeOf(o) { FusionSceneDefault_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return FusionSceneDefault_getPrototypeOf(o); }\n\nfunction FusionSceneDefault_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) FusionSceneDefault_setPrototypeOf(subClass, superClass); }\n\nfunction FusionSceneDefault_setPrototypeOf(o, p) { FusionSceneDefault_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return FusionSceneDefault_setPrototypeOf(o, p); }\n\n\n\n\nvar FusionSceneDefault_LOG = \'[ FusionSceneDefault ]\';\nvar FusionSceneDefault_DEBUG = false;\n\nvar FusionSceneDefault_default =\n/*#__PURE__*/\nfunction (_FusionScene) {\n  FusionSceneDefault_inherits(_default, _FusionScene);\n\n  function _default(player, data) {\n    FusionSceneDefault_classCallCheck(this, _default);\n\n    return FusionSceneDefault_possibleConstructorReturn(this, FusionSceneDefault_getPrototypeOf(_default).call(this, player, data));\n  }\n\n  FusionSceneDefault_createClass(_default, [{\n    key: "load",\n    value: function load() {\n      FusionSceneDefault_DEBUG && console.log(FusionSceneDefault_LOG, \'load()\');\n      this.loadManifest(this.render.bind(this));\n    }\n  }, {\n    key: "loadManifest",\n    value: function loadManifest(resolve) {\n      var _this = this;\n\n      FusionSceneDefault_DEBUG && console.log(FusionSceneDefault_LOG, \'loadManifest()\');\n      var queue = new createjs.LoadQueue(false);\n      queue.loadManifest(this.data.path + \'/manifest.json\', true, \'\');\n      queue.on("fileload", function (evt) {\n        FusionSceneDefault_DEBUG && console.log(FusionSceneDefault_LOG, \'fileload(), \', evt.item.id, evt);\n        _this.data[evt.item.id] = evt.result;\n      });\n      queue.on("complete", function (evt) {\n        FusionSceneDefault_DEBUG && console.log(FusionSceneDefault_LOG, \'loadManifest(), manifest complete...\', evt);\n        resolve();\n      });\n      queue.on("error", function (evt) {\n        console.warn(\'Error in loadManifest() during preloading. \' + evt.message);\n      });\n    }\n  }, {\n    key: "render",\n    value: function render() {\n      // Create Markup\n      this.element = FusionHelper.appendHtml(this.player.viewport, "<div class=\\"fusion--scene fusion--scene--default scene-".concat(this.id, "\\"></div>"));\n      this.content = FusionHelper.appendHtml(this.element, "<div class=\\"fusion--scene--content\\"></div>");\n      FusionHelper.appendHtml(this.content, this.data.html); // Execute scene script\n\n      var scriptElement = document.createElement(\'script\'); // Wrap script to inject additional player/scene data\n\n      var script = "\\n      (function(scene) {\\n        var playerId = \'".concat(this.player.id, "\';\\n        var sceneId = \'").concat(this.id, "\';\\n        var player = window.fusionPlayer[playerId];\\n        var scene = player.getScene(sceneId);\\n\\n        ").concat(this.data.script, "\\n        ").concat(this.data.script2 ? this.data.script2 : \'\', "\\n        ").concat(this.data.script3 ? this.data.script3 : \'\', "\\n        ").concat(this.data.script4 ? this.data.script4 : \'\', "\\n      })();\\n    ");\n      scriptElement.innerHTML = script;\n      this.element.appendChild(scriptElement); // Propagate preready\n\n      this.emit(Const.SCENE_PRE_READY); // Scan for mojo fx\n\n      mojo.fx.FxScanner.scan(this.content);\n    }\n  }]);\n\n  return _default;\n}(FusionScene_default);\n\n\n// CONCATENATED MODULE: ./src/core/MojoFusionPlayer.js\nfunction MojoFusionPlayer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction MojoFusionPlayer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction MojoFusionPlayer_createClass(Constructor, protoProps, staticProps) { if (protoProps) MojoFusionPlayer_defineProperties(Constructor.prototype, protoProps); if (staticProps) MojoFusionPlayer_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction MojoFusionPlayer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\nvar MojoFusionPlayer_LOG = \'[ FusionPlayer ]\';\n/**\n * MojoFusionPlayer Class\n */\n\nvar MojoFusionPlayer_default =\n/*#__PURE__*/\nfunction () {\n  function _default(options) {\n    var _this = this;\n\n    MojoFusionPlayer_classCallCheck(this, _default);\n\n    MojoFusionPlayer_defineProperty(this, "defaults", {\n      overflowX: \'hidden\',\n      overflowY: \'hidden\'\n    });\n\n    MojoFusionPlayer_defineProperty(this, "options", void 0);\n\n    MojoFusionPlayer_defineProperty(this, "wrapper", void 0);\n\n    MojoFusionPlayer_defineProperty(this, "viewport", void 0);\n\n    MojoFusionPlayer_defineProperty(this, "scenes", []);\n\n    window.fusionPlayer = window.fusionPlayer ? window.fusionPlayer : {};\n    window.fusionPlayer[options.id] = this;\n    this.options = Object.assign(this.defaults, options);\n    this.id = options.id;\n    this.wrapper = document.getElementById(options.id);\n    this.wrapper.classList.add(\'fusion--player\');\n    this.createMarkup();\n    this.viewport = this.wrapper.querySelector(\'.fusion--viewport\'); // Viewport is now always 100% of player\n    // this.viewport.style.width = (typeof this.options.width == \'string\') ? this.options.width : `${this.options.width}px`;\n    // this.viewport.style.height = (typeof this.options.height == \'string\') ? this.options.height : `${this.options.height}px`;\n\n    this.viewport.style.overflow = "auto"; // Create scene objects\n\n    this.options.scenes.forEach(function (scene) {\n      scene.width = scene.width || _this.options.width;\n      scene.height = scene.height || _this.options.height;\n\n      switch (scene.iframe) {\n        case true:\n          _this.scenes.push(new FusionSceneIframe_default(_this, scene));\n\n          break;\n\n        default:\n          _this.scenes.push(new FusionSceneDefault_default(_this, scene));\n\n          break;\n      }\n    }); // this.loadScene(\'scene1\');\n  }\n\n  MojoFusionPlayer_createClass(_default, [{\n    key: "createMarkup",\n    value: function createMarkup() {\n      FusionHelper.appendHtml(this.wrapper, \'<div class="fusion--viewport"></div>\');\n    }\n  }, {\n    key: "getScene",\n    value: function getScene(id) {\n      return this.scenes.find(function (item) {\n        return item.id === id;\n      });\n    }\n  }, {\n    key: "loadScene",\n    value: function loadScene(id) {\n      var scene = this.getScene(id);\n\n      if (!scene) {\n        console.error(MojoFusionPlayer_LOG, \'Scene not found:\', id);\n        return;\n      }\n\n      scene.load();\n    }\n  }]);\n\n  return _default;\n}();\n\n\n// EXTERNAL MODULE: ./src/fx/FxScanner.js\nvar FxScanner = __webpack_require__(5);\n\n// CONCATENATED MODULE: ./src/fx/experimental/Magnet.js\nfunction Magnet_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Magnet_typeof = function _typeof(obj) { return typeof obj; }; } else { Magnet_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Magnet_typeof(obj); }\n\nfunction Magnet_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Magnet_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Magnet_createClass(Constructor, protoProps, staticProps) { if (protoProps) Magnet_defineProperties(Constructor.prototype, protoProps); if (staticProps) Magnet_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Magnet_possibleConstructorReturn(self, call) { if (call && (Magnet_typeof(call) === "object" || typeof call === "function")) { return call; } return Magnet_assertThisInitialized(self); }\n\nfunction Magnet_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Magnet_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Magnet_setPrototypeOf(subClass, superClass); }\n\nfunction Magnet_setPrototypeOf(o, p) { Magnet_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Magnet_setPrototypeOf(o, p); }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Magnet_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Magnet_getPrototypeOf(o) { Magnet_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Magnet_getPrototypeOf(o); }\n\nfunction Magnet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Magnet_LOG = \'[ FX : Magnet ]\';\nvar Magnet_DEBUG = false;\n\nvar Magnet_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Magnet_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Magnet_classCallCheck(this, _default);\n\n    _this = Magnet_possibleConstructorReturn(this, Magnet_getPrototypeOf(_default).apply(this, arguments));\n\n    _get(Magnet_getPrototypeOf(_default.prototype), "init", Magnet_assertThisInitialized(_this)).call(Magnet_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Magnet_createClass(_default, [{\n    key: "init",\n    value: function init() {}\n  }, {\n    key: "start",\n    value: function start() {\n      gsap.to(this.element, {\n        scale: this.options.scale,\n        transformOrigin: \'50% 50%\',\n        duration: this.options.duration / 1000,\n        ease: \'power4.out(9)\'\n      });\n    }\n  }, {\n    key: "end",\n    value: function end() {\n      gsap.isTweening(this.element) && gsap.killTweensOf(this.element, \'scale\');\n      gsap.to(this.element, {\n        scale: 1,\n        duration: this.options.duration / 1000,\n        ease: this.options.easeOut\n      });\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nMagnet_defineProperty(Magnet_default, "manifest", {\n  id: \'Magnet\',\n  options: {\n    trigger: \'hover\',\n    duration: 500,\n    scale: 1.2,\n    easeOut: \'back.out(3)\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/fx/experimental/anime/Magnet.js\nfunction anime_Magnet_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { anime_Magnet_typeof = function _typeof(obj) { return typeof obj; }; } else { anime_Magnet_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return anime_Magnet_typeof(obj); }\n\nfunction anime_Magnet_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction anime_Magnet_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction anime_Magnet_createClass(Constructor, protoProps, staticProps) { if (protoProps) anime_Magnet_defineProperties(Constructor.prototype, protoProps); if (staticProps) anime_Magnet_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction anime_Magnet_possibleConstructorReturn(self, call) { if (call && (anime_Magnet_typeof(call) === "object" || typeof call === "function")) { return call; } return anime_Magnet_assertThisInitialized(self); }\n\nfunction anime_Magnet_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction anime_Magnet_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) anime_Magnet_setPrototypeOf(subClass, superClass); }\n\nfunction anime_Magnet_setPrototypeOf(o, p) { anime_Magnet_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return anime_Magnet_setPrototypeOf(o, p); }\n\nfunction Magnet_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Magnet_get = Reflect.get; } else { Magnet_get = function _get(target, property, receiver) { var base = Magnet_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Magnet_get(target, property, receiver || target); }\n\nfunction Magnet_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = anime_Magnet_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction anime_Magnet_getPrototypeOf(o) { anime_Magnet_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return anime_Magnet_getPrototypeOf(o); }\n\nfunction anime_Magnet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar anime_Magnet_LOG = \'[ FX : AnimateMagnet (Anime) ]\';\nvar anime_Magnet_DEBUG = true;\n\nvar anime_Magnet_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  anime_Magnet_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    anime_Magnet_classCallCheck(this, _default);\n\n    _this = anime_Magnet_possibleConstructorReturn(this, anime_Magnet_getPrototypeOf(_default).apply(this, arguments));\n\n    anime_Magnet_defineProperty(anime_Magnet_assertThisInitialized(_this), "an", void 0);\n\n    Magnet_get(anime_Magnet_getPrototypeOf(_default.prototype), "init", anime_Magnet_assertThisInitialized(_this)).call(anime_Magnet_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  anime_Magnet_createClass(_default, [{\n    key: "init",\n    value: function init() {}\n  }, {\n    key: "start",\n    value: function start() {\n      this.cancelAnimation(this.an);\n      this.an = anime({\n        targets: this.element,\n        scale: this.options.scale,\n        duration: 600,\n        easing: \'easeOutExpo\'\n      });\n    }\n  }, {\n    key: "end",\n    value: function end() {\n      // gsap.isTweening(this.element) && gsap.killTweensOf(this.element);\n      // gsap.to(this.element, {scale: 1, duration: 0.4, ease: this.options.easeOut});\n      // this.an.end.restart();\n      this.cancelAnimation(this.an);\n      this.an = anime({\n        targets: this.element,\n        scale: 1,\n        duration: 400,\n        easing: \'easeOutBack\'\n      });\n    }\n  }, {\n    key: "cancelAnimation",\n    value: function cancelAnimation(animation) {\n      animation && animation.pause(); // let activeInstances = anime.running;\n      // let index = activeInstances.indexOf(animation);\n      // activeInstances.splice(index, 1);\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nanime_Magnet_defineProperty(anime_Magnet_default, "manifest", {\n  id: \'Magnet\',\n  options: {\n    scale: 1.2,\n    easeOut: \'back.out(3)\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/fx/experimental/TypeAnimation.js\nfunction TypeAnimation_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { TypeAnimation_typeof = function _typeof(obj) { return typeof obj; }; } else { TypeAnimation_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return TypeAnimation_typeof(obj); }\n\nfunction TypeAnimation_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TypeAnimation_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TypeAnimation_createClass(Constructor, protoProps, staticProps) { if (protoProps) TypeAnimation_defineProperties(Constructor.prototype, protoProps); if (staticProps) TypeAnimation_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction TypeAnimation_possibleConstructorReturn(self, call) { if (call && (TypeAnimation_typeof(call) === "object" || typeof call === "function")) { return call; } return TypeAnimation_assertThisInitialized(self); }\n\nfunction TypeAnimation_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction TypeAnimation_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) TypeAnimation_setPrototypeOf(subClass, superClass); }\n\nfunction TypeAnimation_setPrototypeOf(o, p) { TypeAnimation_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return TypeAnimation_setPrototypeOf(o, p); }\n\nfunction TypeAnimation_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { TypeAnimation_get = Reflect.get; } else { TypeAnimation_get = function _get(target, property, receiver) { var base = TypeAnimation_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return TypeAnimation_get(target, property, receiver || target); }\n\nfunction TypeAnimation_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = TypeAnimation_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction TypeAnimation_getPrototypeOf(o) { TypeAnimation_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return TypeAnimation_getPrototypeOf(o); }\n\nfunction TypeAnimation_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar TypeAnimation_LOG = \'[ FX : TypeAnimation ]\';\nvar TypeAnimation_DEBUG = true;\n\nvar TypeAnimation_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  TypeAnimation_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    TypeAnimation_classCallCheck(this, _default);\n\n    _this = TypeAnimation_possibleConstructorReturn(this, TypeAnimation_getPrototypeOf(_default).apply(this, arguments));\n\n    TypeAnimation_get(TypeAnimation_getPrototypeOf(_default.prototype), "init", TypeAnimation_assertThisInitialized(_this)).call(TypeAnimation_assertThisInitialized(_this));\n\n    TypeAnimation_get(TypeAnimation_getPrototypeOf(_default.prototype), "start", TypeAnimation_assertThisInitialized(_this)).call(TypeAnimation_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  TypeAnimation_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      TypeAnimation_DEBUG && console.log(TypeAnimation_LOG, \'init()\', this.options); // Prepare elements\n      // Wrap every letter in a span\n      // this.element.innerHTML = this.element.textContent.replace(/\\S/g, "<span class=\'letter\'>$&</span>");\n\n      this.element.innerHTML = this.element.textContent.replace(/[\\S\\W]/g, "<span class=\'letter\'>$&</span>").replace(/> </g, ">&nbsp;<");\n      gsap.set(this.element.querySelectorAll(\'.letter\'), {\n        display: \'inline-block\',\n        opacity: 0\n      });\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      TypeAnimation_DEBUG && console.log(TypeAnimation_LOG, \'start()\');\n      gsap.fromTo(this.element.querySelectorAll(\'.letter\'), {\n        scale: 2\n      }, {\n        opacity: 1,\n        scale: 1,\n        delay: this.options.delay,\n        duration: 0.2,\n        stagger: 1 / (this.options.speed / 2),\n        ease: \'back.out(3)\'\n      });\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nTypeAnimation_defineProperty(TypeAnimation_default, "manifest", {\n  id: \'type\',\n  options: {\n    trigger: \'auto\',\n    speed: 100,\n    delay: .5\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/fx/experimental/Particles.js\nfunction Particles_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Particles_typeof = function _typeof(obj) { return typeof obj; }; } else { Particles_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Particles_typeof(obj); }\n\nfunction Particles_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Particles_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Particles_createClass(Constructor, protoProps, staticProps) { if (protoProps) Particles_defineProperties(Constructor.prototype, protoProps); if (staticProps) Particles_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Particles_possibleConstructorReturn(self, call) { if (call && (Particles_typeof(call) === "object" || typeof call === "function")) { return call; } return Particles_assertThisInitialized(self); }\n\nfunction Particles_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Particles_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Particles_setPrototypeOf(subClass, superClass); }\n\nfunction Particles_setPrototypeOf(o, p) { Particles_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Particles_setPrototypeOf(o, p); }\n\nfunction Particles_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Particles_get = Reflect.get; } else { Particles_get = function _get(target, property, receiver) { var base = Particles_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Particles_get(target, property, receiver || target); }\n\nfunction Particles_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Particles_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Particles_getPrototypeOf(o) { Particles_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Particles_getPrototypeOf(o); }\n\nfunction Particles_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Particles_LOG = \'[ FX : Particles ]\';\nvar Particles_DEBUG = true;\n\nvar Particles_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Particles_inherits(_default, _FxBase);\n\n  // Effect center\n  function _default() {\n    var _this;\n\n    Particles_classCallCheck(this, _default);\n\n    _this = Particles_possibleConstructorReturn(this, Particles_getPrototypeOf(_default).apply(this, arguments));\n\n    Particles_defineProperty(Particles_assertThisInitialized(_this), "center", {\n      left: 0,\n      top: 0\n    });\n\n    Particles_get(Particles_getPrototypeOf(_default.prototype), "init", Particles_assertThisInitialized(_this)).call(Particles_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Particles_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      Particles_DEBUG && console.log(Particles_LOG, \'init()\', this.options);\n      mojo.FusionHelper.appendHtml(document.body, "<svg xmlns=\\"http://www.w3.org/2000/svg\\" xmlns:xlink=\\"http://www.w3.org/1999/xlink\\" width=\\"82\\" height=\\"129\\" viewBox=\\"0 0 82 129\\" style=\\"display: none\\">\\n      <circle id=\\"tplCircle\\" cx=\\"9.5\\" cy=\\"9.5\\" r=\\"9.5\\" fill=\\"none\\" stroke=\\"#fff\\" stroke-width=\\"3\\"/>\\n      <path id=\\"tplTriangle\\" d=\\"M9.5,0,19,17H0Z\\" fill=\\"none\\" stroke=\\"#fff\\" stroke-width=\\"3\\"/>\\n      <rect id=\\"tplRect\\" width=\\"19\\" height=\\"19\\" fill=\\"none\\" stroke=\\"#fff\\" stroke-width=\\"3\\"/>\\n    </svg>"); // Gather templates\n\n      this.templates = [{\n        node: document.getElementById(\'tplCircle\')\n      }, {\n        node: document.getElementById(\'tplTriangle\')\n      }, {\n        node: document.getElementById(\'tplRect\')\n      }]; // Cache width/height\n\n      this.templates.forEach(function (item) {\n        var rect = item.node.getBoundingClientRect();\n        item.width = rect.width;\n        item.height = rect.height;\n      });\n    }\n  }, {\n    key: "update",\n    value: function update() {\n      Particles_DEBUG && console.log(Particles_LOG, \'update()\'); // let computedStyle = window.getComputedStyle(this.element);\n      // this.center = {\n      //   left: parseInt(computedStyle.left) + parseInt(computedStyle.width)/2,\n      //   top: parseInt(computedStyle.top) + parseInt(computedStyle.height)/2 \n      // };\n      // DEBUG && console.log(LOG, \'update() center:\', this.center);\n\n      function getLocalBoundingClientRect(el) {\n        var a = el.getBoundingClientRect();\n        var b = el.parentNode.getBoundingClientRect();\n        return {\n          left: a.left - b.left,\n          top: a.top - b.top,\n          width: a.width,\n          height: a.height\n        };\n      }\n\n      var rect = getLocalBoundingClientRect(this.element);\n      this.center = {\n        left: Math.round(rect.left + rect.width / 2),\n        top: Math.round(rect.top + rect.height / 2)\n      };\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      Particles_DEBUG && console.log(Particles_LOG, \'start()\');\n      this.update();\n      var svg = mojo.FusionHelper.appendHtml(this.element.parentElement, "<svg xmlns=\\"http://www.w3.org/2000/svg\\" xmlns:xlink=\\"http://www.w3.org/1999/xlink\\" width=\\"1\\" height=\\"1\\" viewBox=\\"0 0 1 1\\" style=\\"pointer-events: none; position: absolute; overflow: visible;\\"></svg>");\n      svg.style.left = this.center.left + \'px\';\n      svg.style.top = this.center.top + \'px\'; // Generate\n\n      for (var i = 0; i < 5; i++) {\n        var tpl = this.templates[Math.ceil(Math.random() * this.templates.length) - 1];\n        var node = tpl.node.cloneNode();\n        node.setAttribute(\'id\', \'random-\' + Math.round(Math.random() * 10000000000));\n        node.style.display = \'block\';\n        node.style.opacity = 0; // node.style.transform = \'translate(\'+(originX-tpl.width/2)+\'px, \'+(originY-tpl.height/2)+\'px)\';\n\n        node.style.transform = \'translate(-10px, -10px)\';\n        svg.appendChild(node); //gsap.to(node, {duration: 0.2*i, opacity: 1, y: \'-=80\', rotation: 360, transformOrigin: "50% 50%"});\n\n        var tl = gsap.timeline({\n          delay: 0.05 * i\n        }); // tl.timeScale(0.1);\n\n        var x = i % 2 ? -40 * (Math.random() * 2 * this.options.power) : 40 * (Math.random() * 2 * this.options.power);\n        var y = -30 * (i / 2 + 1) * this.options.power;\n        tl.to(node, {\n          duration: 1.4,\n          ease: "power3.out",\n          x: x,\n          y: y,\n          rotation: 130,\n          scale: this.options.scale,\n          transformOrigin: "50% 50%"\n        }, 0);\n        tl.to(node, {\n          duration: 0.2,\n          opacity: 1\n        }, 0);\n        tl.to(node, {\n          duration: 0.3,\n          opacity: 0\n        }, "-=".concat(0.3 * this.options.decay));\n        tl.eventCallback("onComplete", function (node) {\n          var parentNode = node.parentNode;\n          parentNode.removeChild(node);\n\n          if (parentNode.children.length == 0) {\n            parentNode.parentNode.removeChild(parentNode);\n          }\n        }, [node]);\n      }\n    }\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nParticles_defineProperty(Particles_default, "manifest", {\n  id: \'Particles\',\n  options: {\n    trigger: \'click\',\n    scale: 2,\n    power: 2,\n    decay: 3\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/fx/experimental/Spritesheet.js\nfunction Spritesheet_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Spritesheet_typeof = function _typeof(obj) { return typeof obj; }; } else { Spritesheet_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Spritesheet_typeof(obj); }\n\nfunction Spritesheet_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Spritesheet_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Spritesheet_createClass(Constructor, protoProps, staticProps) { if (protoProps) Spritesheet_defineProperties(Constructor.prototype, protoProps); if (staticProps) Spritesheet_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Spritesheet_possibleConstructorReturn(self, call) { if (call && (Spritesheet_typeof(call) === "object" || typeof call === "function")) { return call; } return Spritesheet_assertThisInitialized(self); }\n\nfunction Spritesheet_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Spritesheet_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Spritesheet_setPrototypeOf(subClass, superClass); }\n\nfunction Spritesheet_setPrototypeOf(o, p) { Spritesheet_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Spritesheet_setPrototypeOf(o, p); }\n\nfunction Spritesheet_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Spritesheet_get = Reflect.get; } else { Spritesheet_get = function _get(target, property, receiver) { var base = Spritesheet_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Spritesheet_get(target, property, receiver || target); }\n\nfunction Spritesheet_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Spritesheet_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Spritesheet_getPrototypeOf(o) { Spritesheet_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Spritesheet_getPrototypeOf(o); }\n\nfunction Spritesheet_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Spritesheet_LOG = \'[ FX : Spritesheet ]\';\nvar Spritesheet_DEBUG = false;\n\nvar Spritesheet_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Spritesheet_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Spritesheet_classCallCheck(this, _default);\n\n    _this = Spritesheet_possibleConstructorReturn(this, Spritesheet_getPrototypeOf(_default).apply(this, arguments));\n\n    Spritesheet_defineProperty(Spritesheet_assertThisInitialized(_this), "tl", void 0);\n\n    Spritesheet_get(Spritesheet_getPrototypeOf(_default.prototype), "init", Spritesheet_assertThisInitialized(_this)).call(Spritesheet_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Spritesheet_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      Spritesheet_DEBUG && console.log(Spritesheet_LOG, \'options:\', this.options); // Prepare\n      //#BUG: getBoundingClientRect() is always non-scaled in global space\n      // let bounds = this.element.getBoundingClientRect();\n      // !(this.options.width) && (this.options.width = bounds.width); \n      // !(this.options.height) && (this.options.height = bounds.height);\n      // offsetWidth/offsetHeight seems to work better with scaling\n\n      !this.options.width && (this.options.width = this.element.offsetWidth);\n      !this.options.height && (this.options.height = this.element.offsetHeight); // // Set background image\n\n      this.element.style.backgroundImage = "url(".concat(this.options.src, ")");\n      this.element.style.backgroundPosition = "0 0";\n      this.element.style.backgroundSize = "".concat(this.options.width * this.options.steps, "px");\n      this.element.style.backgroundRepeat = "no-repeat";\n      this.tl = gsap.timeline({\n        paused: true,\n        repeat: this.options.loop ? -1 : 0\n      });\n      this.tl.add(gsap.to(this.element, {\n        duration: this.options.duration / 1000,\n        backgroundPositionX: "-".concat(this.options.width * (this.options.steps - 1), "px"),\n        ease: "steps(".concat(this.options.steps - 1, ")")\n      }));\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      this.tl.play();\n    }\n  }, {\n    key: "end",\n    value: function end() {\n      this.tl.reverse();\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nSpritesheet_defineProperty(Spritesheet_default, "manifest", {\n  id: \'Spritesheet\',\n  options: {\n    trigger: \'click\',\n    loop: false,\n    duration: 500,\n    width: undefined,\n    height: undefined,\n    steps: undefined\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/fx/experimental/Jump.js\nfunction Jump_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Jump_typeof = function _typeof(obj) { return typeof obj; }; } else { Jump_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Jump_typeof(obj); }\n\nfunction Jump_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Jump_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Jump_createClass(Constructor, protoProps, staticProps) { if (protoProps) Jump_defineProperties(Constructor.prototype, protoProps); if (staticProps) Jump_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Jump_possibleConstructorReturn(self, call) { if (call && (Jump_typeof(call) === "object" || typeof call === "function")) { return call; } return Jump_assertThisInitialized(self); }\n\nfunction Jump_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Jump_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Jump_setPrototypeOf(subClass, superClass); }\n\nfunction Jump_setPrototypeOf(o, p) { Jump_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Jump_setPrototypeOf(o, p); }\n\nfunction Jump_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Jump_get = Reflect.get; } else { Jump_get = function _get(target, property, receiver) { var base = Jump_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Jump_get(target, property, receiver || target); }\n\nfunction Jump_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Jump_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Jump_getPrototypeOf(o) { Jump_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Jump_getPrototypeOf(o); }\n\nfunction Jump_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Jump_LOG = \'[ FX : Jump ]\';\nvar Jump_DEBUG = false;\n\nvar Jump_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Jump_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Jump_classCallCheck(this, _default);\n\n    _this = Jump_possibleConstructorReturn(this, Jump_getPrototypeOf(_default).apply(this, arguments));\n\n    Jump_defineProperty(Jump_assertThisInitialized(_this), "initial", void 0);\n\n    Jump_get(Jump_getPrototypeOf(_default.prototype), "init", Jump_assertThisInitialized(_this)).call(Jump_assertThisInitialized(_this));\n\n    Jump_get(Jump_getPrototypeOf(_default.prototype), "start", Jump_assertThisInitialized(_this)).call(Jump_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Jump_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      Jump_DEBUG && console.log(Jump_LOG, \'init()\', this.options);\n      this.initial = {\n        y: gsap.getProperty(this.element, \'y\')\n      };\n      Jump_DEBUG && console.log(Jump_LOG, \'this.initial\', this.initial);\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      Jump_DEBUG && console.log(Jump_LOG, \'start()\');\n      gsap.to(this.element, {\n        y: this.initial.y - 20,\n        duration: 0.4,\n        ease: \'power.out(4)\'\n      });\n      gsap.to(this.element, {\n        y: this.initial.y,\n        duration: 0.5,\n        delay: 0.5,\n        ease: \'bounce.out(20)\'\n      });\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nJump_defineProperty(Jump_default, "manifest", {\n  id: \'jump\',\n  options: {}\n});\n\n\n// CONCATENATED MODULE: ./src/fx/experimental/HandCursor.js\nfunction HandCursor_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { HandCursor_typeof = function _typeof(obj) { return typeof obj; }; } else { HandCursor_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return HandCursor_typeof(obj); }\n\nfunction HandCursor_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction HandCursor_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction HandCursor_createClass(Constructor, protoProps, staticProps) { if (protoProps) HandCursor_defineProperties(Constructor.prototype, protoProps); if (staticProps) HandCursor_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction HandCursor_possibleConstructorReturn(self, call) { if (call && (HandCursor_typeof(call) === "object" || typeof call === "function")) { return call; } return HandCursor_assertThisInitialized(self); }\n\nfunction HandCursor_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction HandCursor_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) HandCursor_setPrototypeOf(subClass, superClass); }\n\nfunction HandCursor_setPrototypeOf(o, p) { HandCursor_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return HandCursor_setPrototypeOf(o, p); }\n\nfunction HandCursor_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { HandCursor_get = Reflect.get; } else { HandCursor_get = function _get(target, property, receiver) { var base = HandCursor_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return HandCursor_get(target, property, receiver || target); }\n\nfunction HandCursor_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = HandCursor_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction HandCursor_getPrototypeOf(o) { HandCursor_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return HandCursor_getPrototypeOf(o); }\n\nfunction HandCursor_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar HandCursor_LOG = \'[ FX : HandCursor ]\';\nvar HandCursor_DEBUG = true;\n\nvar HandCursor_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  HandCursor_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    HandCursor_classCallCheck(this, _default);\n\n    _this = HandCursor_possibleConstructorReturn(this, HandCursor_getPrototypeOf(_default).apply(this, arguments));\n\n    HandCursor_get(HandCursor_getPrototypeOf(_default.prototype), "init", HandCursor_assertThisInitialized(_this)).call(HandCursor_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  HandCursor_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      HandCursor_DEBUG && console.log(HandCursor_LOG, \'init()\', this.options);\n      this.element.style.cursor = \'pointer\';\n    }\n  }, {\n    key: "start",\n    value: function start() {}\n    /**\n     * Generate elements\n     */\n\n  }, {\n    key: "generateElements",\n    value: function generateElements() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nHandCursor_defineProperty(HandCursor_default, "manifest", {\n  id: \'hand-cursor\',\n  options: {\n    trigger: \'auto\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/fx/experimental/Glitch.js\nfunction Glitch_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Glitch_typeof = function _typeof(obj) { return typeof obj; }; } else { Glitch_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Glitch_typeof(obj); }\n\nfunction Glitch_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Glitch_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Glitch_createClass(Constructor, protoProps, staticProps) { if (protoProps) Glitch_defineProperties(Constructor.prototype, protoProps); if (staticProps) Glitch_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Glitch_possibleConstructorReturn(self, call) { if (call && (Glitch_typeof(call) === "object" || typeof call === "function")) { return call; } return Glitch_assertThisInitialized(self); }\n\nfunction Glitch_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Glitch_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Glitch_setPrototypeOf(subClass, superClass); }\n\nfunction Glitch_setPrototypeOf(o, p) { Glitch_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Glitch_setPrototypeOf(o, p); }\n\nfunction Glitch_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Glitch_get = Reflect.get; } else { Glitch_get = function _get(target, property, receiver) { var base = Glitch_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Glitch_get(target, property, receiver || target); }\n\nfunction Glitch_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Glitch_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Glitch_getPrototypeOf(o) { Glitch_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Glitch_getPrototypeOf(o); }\n\nfunction Glitch_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Glitch_LOG = \'[ FX : Glitch ]\';\nvar Glitch_DEBUG = true;\n\nvar Glitch_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Glitch_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Glitch_classCallCheck(this, _default);\n\n    _this = Glitch_possibleConstructorReturn(this, Glitch_getPrototypeOf(_default).apply(this, arguments));\n    _this.original;\n    _this.computedStyle;\n\n    Glitch_get(Glitch_getPrototypeOf(_default.prototype), "init", Glitch_assertThisInitialized(_this)).call(Glitch_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Glitch_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      Glitch_DEBUG && console.log(Glitch_LOG, \'init()\', this.options); // Prepare elements\n\n      var computedStyle = this.computedStyle = window.getComputedStyle(this.element);\n      this.original = this.element; // Wrap everything in div\n\n      this.element = document.createElement(\'div\');\n      this.element.style.position = computedStyle.position;\n      this.element.style.width = computedStyle.width;\n      this.element.style.height = computedStyle.height;\n      this.element.style.top = computedStyle.top;\n      this.element.style.left = computedStyle.left; // this.element.style.overflow = \'hidden\';\n\n      this.element.setAttribute(\'mojo-fx-glitch\', this.original.getAttribute(\'mojo-fx-glitch\'));\n      this.original.removeAttribute(\'mojo-fx-glitch\');\n      this.original.parentNode.insertBefore(this.element, this.original);\n      this.element.appendChild(this.original); // Wrap original in div (for masking etc.)\n\n      var layerWrapper = document.createElement(\'div\');\n      this.original.parentNode.insertBefore(layerWrapper, this.original);\n      layerWrapper.appendChild(this.original);\n      this.original = layerWrapper; // gsap.set(this.original, {opacity: 0});\n      // Generate Elements\n\n      this.generateElements();\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      var _this2 = this;\n\n      Glitch_DEBUG && console.log(Glitch_LOG, \'start()\');\n      var glitched = this.element.querySelectorAll(\'.glitched\');\n      gsap.set(glitched, {\n        opacity: 0\n      });\n      var tl = gsap.timeline({\n        repeat: this.options.loop,\n        repeatDelay: 0\n      });\n      glitched.forEach(function (item, index) {\n        var power = _this2.options.power * 40;\n        var layerTl = gsap.timeline();\n        layerTl.to(item, {\n          duration: 0.04,\n          opacity: 1,\n          x: (Math.random() - 0.5) * power\n        }, "+=0.05");\n        layerTl.to(item, {\n          duration: 0.04,\n          opacity: 0,\n          x: 0\n        }, "+=0.05");\n        layerTl.to({}, {\n          duration: 0.1\n        });\n        layerTl.to(item, {\n          duration: 0.04,\n          opacity: 1,\n          x: (Math.random() - 0.5) * power * 1.5\n        }, "+=0");\n        layerTl.to(item, {\n          duration: 0.04,\n          opacity: 0,\n          x: 0\n        }, "+=0.05");\n        layerTl.to({}, {\n          duration: 0.1\n        });\n        layerTl.to(item, {\n          duration: 0.04,\n          opacity: 1,\n          x: (Math.random() - 0.5) * power\n        }, "+=0");\n        layerTl.to(item, {\n          duration: 0.04,\n          opacity: 0,\n          x: 0\n        }, "+=0.05");\n        layerTl.to({}, {\n          duration: 0.1\n        });\n        layerTl.to(item, {\n          duration: 0.04,\n          opacity: 1,\n          x: (Math.random() - 0.5) * power\n        }, "+=0.05");\n        layerTl.to(item, {\n          duration: 0.04,\n          opacity: 0,\n          x: 0\n        }, "+=0.05"); // layerTl.to({}, {duration: (Math.random()/10)});\n\n        layerTl.to({}, {\n          duration: Math.random() / 2\n        }); // tl.add( layerTl, index/20 );\n\n        tl.add(layerTl, 0); // tl.add( layerTl, 0.5 );\n      });\n    }\n    /**\n     * Generate elements\n     */\n\n  }, {\n    key: "generateElements",\n    value: function generateElements() {\n      // console.log(this.computedStyle.width);\n      for (var i = 0; i < 20; i++) {\n        var clone = this.original.cloneNode(true);\n        clone.classList.add(\'glitched\');\n        clone.style.position = \'absolute\';\n        clone.style.top = "".concat(i * 60, "px");\n        clone.style.left = 0;\n        clone.style.width = this.computedStyle.width; // clone.style.height = \'30px\';\n        // clone.style.height = `${5 + Math.random()*80}px`;\n\n        clone.style.height = "".concat(2 + Math.random() * 100, "px"); // clone.style.filter = \'grayscale(50%)\';\n        // clone.style.filter = `brightness(1.2)`;\n\n        clone.style.pointerEvents = \'none\';\n        clone.style.overflow = \'hidden\';\n        var child = clone.firstChild;\n        child.style.position = \'absolute\';\n        child.style.top = "".concat(i * -60, "px");\n        child.style.left = \'0px\';\n        this.element.appendChild(clone);\n      }\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nGlitch_defineProperty(Glitch_default, "manifest", {\n  id: \'Glitch\',\n  options: {\n    power: 1,\n    loop: 0\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/fx/experimental/Debugger.js\nfunction Debugger_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Debugger_typeof = function _typeof(obj) { return typeof obj; }; } else { Debugger_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Debugger_typeof(obj); }\n\nfunction Debugger_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Debugger_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Debugger_createClass(Constructor, protoProps, staticProps) { if (protoProps) Debugger_defineProperties(Constructor.prototype, protoProps); if (staticProps) Debugger_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Debugger_possibleConstructorReturn(self, call) { if (call && (Debugger_typeof(call) === "object" || typeof call === "function")) { return call; } return Debugger_assertThisInitialized(self); }\n\nfunction Debugger_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Debugger_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Debugger_setPrototypeOf(subClass, superClass); }\n\nfunction Debugger_setPrototypeOf(o, p) { Debugger_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Debugger_setPrototypeOf(o, p); }\n\nfunction Debugger_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Debugger_get = Reflect.get; } else { Debugger_get = function _get(target, property, receiver) { var base = Debugger_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Debugger_get(target, property, receiver || target); }\n\nfunction Debugger_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Debugger_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Debugger_getPrototypeOf(o) { Debugger_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Debugger_getPrototypeOf(o); }\n\nfunction Debugger_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Debugger_LOG = \'[ FX : Debugger ]\';\nvar Debugger_DEBUG = true;\n\nvar Debugger_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Debugger_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Debugger_classCallCheck(this, _default);\n\n    _this = Debugger_possibleConstructorReturn(this, Debugger_getPrototypeOf(_default).apply(this, arguments));\n\n    Debugger_get(Debugger_getPrototypeOf(_default.prototype), "init", Debugger_assertThisInitialized(_this)).call(Debugger_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Debugger_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      console.log(\'\\n\\n\');\n\n      function getLocalBoundingClientRect(el) {\n        var a = el.getBoundingClientRect();\n        var b = el.parentNode.getBoundingClientRect();\n        return {\n          left: a.left - b.left,\n          top: a.top - b.top,\n          width: a.width,\n          height: a.height\n        };\n      } // Client Rect\n\n\n      var clientRect = this.element.getBoundingClientRect();\n      console.log(\'clientRect:\', clientRect);\n      var parentClientRect = this.element.parentNode.getBoundingClientRect();\n      console.log(\'parentClientRect:\', parentClientRect);\n      console.log(\'local rect:\', getLocalBoundingClientRect(this.element));\n    }\n  }, {\n    key: "start",\n    value: function start() {}\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nDebugger_defineProperty(Debugger_default, "manifest", {\n  id: \'Debugger\',\n  options: {\n    trigger: \'auto\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/fx/experimental/GlitchCanvas.js\nfunction GlitchCanvas_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { GlitchCanvas_typeof = function _typeof(obj) { return typeof obj; }; } else { GlitchCanvas_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return GlitchCanvas_typeof(obj); }\n\nfunction GlitchCanvas_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction GlitchCanvas_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction GlitchCanvas_createClass(Constructor, protoProps, staticProps) { if (protoProps) GlitchCanvas_defineProperties(Constructor.prototype, protoProps); if (staticProps) GlitchCanvas_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction GlitchCanvas_possibleConstructorReturn(self, call) { if (call && (GlitchCanvas_typeof(call) === "object" || typeof call === "function")) { return call; } return GlitchCanvas_assertThisInitialized(self); }\n\nfunction GlitchCanvas_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction GlitchCanvas_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) GlitchCanvas_setPrototypeOf(subClass, superClass); }\n\nfunction GlitchCanvas_setPrototypeOf(o, p) { GlitchCanvas_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return GlitchCanvas_setPrototypeOf(o, p); }\n\nfunction GlitchCanvas_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { GlitchCanvas_get = Reflect.get; } else { GlitchCanvas_get = function _get(target, property, receiver) { var base = GlitchCanvas_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return GlitchCanvas_get(target, property, receiver || target); }\n\nfunction GlitchCanvas_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = GlitchCanvas_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction GlitchCanvas_getPrototypeOf(o) { GlitchCanvas_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return GlitchCanvas_getPrototypeOf(o); }\n\nfunction GlitchCanvas_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar GlitchCanvas_LOG = \'[ FX : GlitchCanvas ]\';\nvar GlitchCanvas_DEBUG = true;\n\nvar GlitchCanvas_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  GlitchCanvas_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    GlitchCanvas_classCallCheck(this, _default);\n\n    _this = GlitchCanvas_possibleConstructorReturn(this, GlitchCanvas_getPrototypeOf(_default).apply(this, arguments));\n\n    GlitchCanvas_get(GlitchCanvas_getPrototypeOf(_default.prototype), "init", GlitchCanvas_assertThisInitialized(_this)).call(GlitchCanvas_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  GlitchCanvas_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      var _this2 = this;\n\n      //---\n      // Inspired by https://codepen.io/Blummed/pen/lCjiu?editors=0010\n      console.log(GlitchCanvas_LOG, \'options:\', this.options); // Get the device pixel ratio, falling back to 1.\n\n      var dpr = window.devicePixelRatio || 1; // Prepare elements\n\n      this.original = this.element; // let bounds = this.original.getBoundingClientRect();\n      // let computedStyle = window.getComputedStyle(this.original);\n      // Replace element /w canvas\n\n      this.element = document.createElement(\'canvas\');\n      this.original.parentNode.insertBefore(this.element, this.original);\n      this.original.style.opacity = .1;\n      var canvas = this.element;\n      var context = canvas.getContext(\'2d\'),\n          img = new Image(),\n          w,\n          h,\n          offset,\n          glitchInterval,\n          scale;\n      context.scale(dpr, dpr);\n      img.src = this.original.getAttribute(\'src\');\n\n      img.onload = function () {\n        init();\n        window.onresize = init;\n      };\n\n      var init = function init() {\n        clearInterval(glitchInterval);\n\n        var bounds = _this2.original.getBoundingClientRect();\n\n        var computedStyle = window.getComputedStyle(_this2.original);\n        canvas.style.width = computedStyle.width;\n        canvas.style.height = computedStyle.height;\n        canvas.style.left = computedStyle.left;\n        canvas.style.top = computedStyle.top;\n        canvas.style.transform = computedStyle.transform;\n        canvas.width = w = bounds.width * dpr;\n        canvas.height = h = bounds.height * dpr;\n        scale = img.width / w;\n        glitchInterval = setInterval(function () {\n          clear();\n          setTimeout(glitchImg, randInt(250, 1000));\n        }, 300);\n      };\n\n      var clear = function clear() {\n        context.clearRect(0, 0, w * dpr, h * dpr);\n      };\n\n      var glitchImg = function glitchImg() {\n        for (var i = 0; i < randInt(1, 13); i++) {\n          var x = Math.random() * w * dpr;\n          var y = Math.random() * h * dpr;\n          var spliceWidth = w * dpr - x;\n          var spliceHeight = randInt(5, h * dpr / 3); // context.drawImage(canvas, 0, y, spliceWidth, spliceHeight, x, y, spliceWidth*dpr, spliceHeight*dpr);\n          // context.drawImage(canvas, spliceWidth, y, x, spliceHeight, 0, y, x, spliceHeight*dpr);\n          // WORKING\n          // context.drawImage(img, 0, 200, img.width, 100, 0, 200/scale, w, 100/scale);\n\n          context.drawImage(img, 0, 200, img.width, 100, 0, 200 / scale, w, 100 / scale);\n        }\n      };\n\n      var randInt = function randInt(a, b) {\n        return ~~(Math.random() * (b - a) + a);\n      };\n    }\n  }, {\n    key: "start",\n    value: function start() {}\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nGlitchCanvas_defineProperty(GlitchCanvas_default, "manifest", {\n  id: \'glitch-canvas\',\n  options: {\n    trigger: \'hover\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/fx/experimental/GlitchEasel.js\nfunction GlitchEasel_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { GlitchEasel_typeof = function _typeof(obj) { return typeof obj; }; } else { GlitchEasel_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return GlitchEasel_typeof(obj); }\n\nfunction GlitchEasel_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction GlitchEasel_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction GlitchEasel_createClass(Constructor, protoProps, staticProps) { if (protoProps) GlitchEasel_defineProperties(Constructor.prototype, protoProps); if (staticProps) GlitchEasel_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction GlitchEasel_possibleConstructorReturn(self, call) { if (call && (GlitchEasel_typeof(call) === "object" || typeof call === "function")) { return call; } return GlitchEasel_assertThisInitialized(self); }\n\nfunction GlitchEasel_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction GlitchEasel_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) GlitchEasel_setPrototypeOf(subClass, superClass); }\n\nfunction GlitchEasel_setPrototypeOf(o, p) { GlitchEasel_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return GlitchEasel_setPrototypeOf(o, p); }\n\nfunction GlitchEasel_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { GlitchEasel_get = Reflect.get; } else { GlitchEasel_get = function _get(target, property, receiver) { var base = GlitchEasel_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return GlitchEasel_get(target, property, receiver || target); }\n\nfunction GlitchEasel_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = GlitchEasel_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction GlitchEasel_getPrototypeOf(o) { GlitchEasel_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return GlitchEasel_getPrototypeOf(o); }\n\nfunction GlitchEasel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar GlitchEasel_LOG = \'[ FX : GlitchEasel ]\';\nvar GlitchEasel_DEBUG = true;\n\nvar GlitchEasel_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  GlitchEasel_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    GlitchEasel_classCallCheck(this, _default);\n\n    _this = GlitchEasel_possibleConstructorReturn(this, GlitchEasel_getPrototypeOf(_default).apply(this, arguments));\n\n    GlitchEasel_defineProperty(GlitchEasel_assertThisInitialized(_this), "canvas", void 0);\n\n    GlitchEasel_defineProperty(GlitchEasel_assertThisInitialized(_this), "stage", void 0);\n\n    GlitchEasel_defineProperty(GlitchEasel_assertThisInitialized(_this), "width", void 0);\n\n    GlitchEasel_defineProperty(GlitchEasel_assertThisInitialized(_this), "height", void 0);\n\n    GlitchEasel_defineProperty(GlitchEasel_assertThisInitialized(_this), "dpr", !window.devicePixelRatio ? 1 : window.devicePixelRatio >= 2 ? 2 : 1);\n\n    GlitchEasel_defineProperty(GlitchEasel_assertThisInitialized(_this), "segments", []);\n\n    GlitchEasel_get(GlitchEasel_getPrototypeOf(_default.prototype), "init", GlitchEasel_assertThisInitialized(_this)).call(GlitchEasel_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  GlitchEasel_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      var _this2 = this;\n\n      // Save original image\n      this.original = this.element; // Create canvas\n\n      var canvas = this.canvas = document.createElement(\'canvas\');\n      this.stage = new createjs.Stage(this.canvas);\n      this.original.parentNode.insertBefore(this.canvas, this.original.nextSibling);\n      this.original.style.opacity = 0;\n      this.original.style.pointerEvents = \'none\';\n      var computedStyle = window.getComputedStyle(this.original);\n      canvas.style.width = computedStyle.width;\n      canvas.style.height = computedStyle.height;\n      canvas.style.left = computedStyle.left;\n      canvas.style.top = computedStyle.top;\n      canvas.style.transform = computedStyle.transform; // canvas.style.pointerEvents = \'none\';\n\n      this.width = parseInt(computedStyle.width) * this.dpr;\n      this.height = parseInt(computedStyle.height) * this.dpr;\n      var rect = canvas.getBoundingClientRect();\n      console.log(22, rect);\n      canvas.width = rect.width * this.dpr;\n      canvas.height = rect.height * this.dpr;\n      canvas.getContext(\'2d\').scale(this.dpr, this.dpr);\n      this.element = this.canvas; // Create segments\n\n      var seedIndex = 0,\n          top = 0;\n\n      while (true) {\n        var seed = Math.round(this.options.seed[seedIndex] * this.options.factor);\n        var image = new createjs.Bitmap(this.original.getAttribute(\'src\'));\n        var shape = new createjs.Shape();\n        shape.graphics.beginFill("#FFFFFF").drawRect(0, top, this.width, seed);\n        image.mask = shape;\n        this.stage.addChild(image);\n        this.segments.push(image); // End\n\n        if (top >= parseInt(computedStyle.height) * this.dpr) break; // Iterate \n\n        top += seed;\n        seedIndex = seedIndex >= this.options.seed.length - 1 ? 0 : ++seedIndex;\n      } // Timeline\n\n\n      this.timeline = gsap.timeline({\n        paused: true,\n        delay: this.options.delay / 1000,\n        repeat: this.options.repeat,\n        repeatDelay: this.options.repeatDelay / 1000,\n        yoyo: this.options.yoyo,\n        onUpdate: this.stage.update.bind(this.stage)\n      });\n      this.segments.forEach(function (segment, index) {\n        _this2.timeline.from(segment, {\n          x: (Math.random() - .5) * 20 * _this2.options.power,\n          alpha: 0,\n          duration: 0.5,\n          ease: _this2.options.easeing\n        }, "".concat(index * _this2.options.stagger / 1000));\n      });\n      this.timeline.timeScale(this.timeline.duration() / (this.options.duration / 1000));\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      this.timeline.play();\n    }\n  }, {\n    key: "end",\n    value: function end() {\n      this.timeline.reverse();\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nGlitchEasel_defineProperty(GlitchEasel_default, "manifest", {\n  id: \'glitch-easel\',\n  options: {\n    trigger: \'hover\',\n    duration: 1000,\n    delay: 0,\n    repeat: 0,\n    repeatDelay: 1000,\n    yoyo: true,\n    seed: [1, 6, 3, 1, 3, 8, 2, 1, 9, 4, 7, 1],\n    factor: 10,\n    power: 80,\n    stagger: 10,\n    easing: \'power4.inOut\' // back.out(3),\n\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/fx/experimental/GlitchAppear.js\nfunction GlitchAppear_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { GlitchAppear_typeof = function _typeof(obj) { return typeof obj; }; } else { GlitchAppear_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return GlitchAppear_typeof(obj); }\n\nfunction GlitchAppear_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction GlitchAppear_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction GlitchAppear_createClass(Constructor, protoProps, staticProps) { if (protoProps) GlitchAppear_defineProperties(Constructor.prototype, protoProps); if (staticProps) GlitchAppear_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction GlitchAppear_possibleConstructorReturn(self, call) { if (call && (GlitchAppear_typeof(call) === "object" || typeof call === "function")) { return call; } return GlitchAppear_assertThisInitialized(self); }\n\nfunction GlitchAppear_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction GlitchAppear_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) GlitchAppear_setPrototypeOf(subClass, superClass); }\n\nfunction GlitchAppear_setPrototypeOf(o, p) { GlitchAppear_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return GlitchAppear_setPrototypeOf(o, p); }\n\nfunction GlitchAppear_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { GlitchAppear_get = Reflect.get; } else { GlitchAppear_get = function _get(target, property, receiver) { var base = GlitchAppear_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return GlitchAppear_get(target, property, receiver || target); }\n\nfunction GlitchAppear_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = GlitchAppear_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction GlitchAppear_getPrototypeOf(o) { GlitchAppear_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return GlitchAppear_getPrototypeOf(o); }\n\nfunction GlitchAppear_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar GlitchAppear_LOG = \'[ FX : GlitchAppear ]\';\nvar GlitchAppear_DEBUG = true;\n\nvar GlitchAppear_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  GlitchAppear_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    GlitchAppear_classCallCheck(this, _default);\n\n    _this = GlitchAppear_possibleConstructorReturn(this, GlitchAppear_getPrototypeOf(_default).apply(this, arguments));\n    _this.original;\n    _this.computedStyle;\n\n    GlitchAppear_get(GlitchAppear_getPrototypeOf(_default.prototype), "init", GlitchAppear_assertThisInitialized(_this)).call(GlitchAppear_assertThisInitialized(_this)); // super.start();\n\n\n    return _this;\n  }\n\n  GlitchAppear_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      GlitchAppear_DEBUG && console.log(GlitchAppear_LOG, \'init()\', this.options); // Prepare elements\n\n      this.original = this.element;\n      var computedStyle = this.computedStyle = window.getComputedStyle(this.original); // Wrap everything in div\n\n      this.element = document.createElement(\'div\');\n      this.element.style.position = computedStyle.position;\n      this.element.style.width = computedStyle.width;\n      this.element.style.height = computedStyle.height;\n      this.element.style.top = computedStyle.top;\n      this.element.style.left = computedStyle.left; // this.element.style.backgroundColor = \'#BADA55\';\n\n      this.element.style.overflow = \'hidden\';\n      this.element.setAttribute(\'mojo-fx-glitch\', this.original.getAttribute(\'mojo-fx-glitch\'));\n      this.original.removeAttribute(\'mojo-fx-glitch\');\n      this.original.parentNode.insertBefore(this.element, this.original);\n      this.element.appendChild(this.original); // Wrap original in div (for masking etc.)\n\n      var layerWrapper = document.createElement(\'div\');\n      this.original.parentNode.insertBefore(layerWrapper, this.original);\n      layerWrapper.appendChild(this.original);\n      this.original = layerWrapper; // Generate Elements\n\n      this.generateElements();\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      GlitchAppear_DEBUG && console.log(GlitchAppear_LOG, \'start()\');\n      var glitched = this.element.querySelectorAll(\'.glitched\');\n      gsap.set(this.original, {\n        opacity: 0\n      });\n      gsap.set(glitched, {\n        opacity: 0\n      });\n      var tl = gsap.timeline({\n        delay: this.options.delay / 1000\n      });\n      glitched.forEach(function (item, index) {\n        // let power = 20;\n        var power = 30;\n        var layerTl = gsap.timeline();\n        layerTl.to(item, {\n          duration: 0.04,\n          opacity: 0.2,\n          x: (Math.random() - 0.5) * power\n        }, "+=0.02");\n        layerTl.to(item, {\n          duration: 0.04,\n          opacity: 0.4,\n          x: 0\n        }, "+=0.02");\n        layerTl.to(item, {\n          duration: 0.04,\n          opacity: 0.6,\n          x: (Math.random() - 0.5) * power\n        }, "+=0");\n        layerTl.to(item, {\n          duration: 0.04,\n          opacity: 0.8,\n          x: 0\n        }, "+=0.02");\n        layerTl.to({}, {\n          duration: 0.02\n        });\n        layerTl.to(item, {\n          duration: 0.04,\n          opacity: 1,\n          x: (Math.random() - 0.5) * power\n        }, "+=0"); // layerTl.to(item, {duration: 0.04, opacity: 1, x: 0}, `+=0.02`);\n        // layerTl.to(item, {duration: 0.04, opacity: 1, x: (Math.random()-0.5)*power}, `+=0.02`);\n\n        layerTl.to(item, {\n          duration: 0.04,\n          opacity: 1,\n          x: 0\n        }, "+=0.02");\n        tl.add(layerTl, index / 10); // tl.add( layerTl, 0.5 );\n      }); // tl.to(this.original, {duration: 0.2, opacity: 1}, .5);\n    }\n  }, {\n    key: "end",\n    value: function end() {}\n    /**\n     * Generate elements\n     */\n\n  }, {\n    key: "generateElements",\n    value: function generateElements() {\n      // console.log(this.computedStyle.width);\n      for (var i = 0; i < 10; i++) {\n        var clone = this.original.cloneNode(true);\n        clone.classList.add(\'glitched\');\n        clone.style.position = \'absolute\';\n        clone.style.top = "".concat(i * 60, "px");\n        clone.style.left = 0;\n        clone.style.width = this.computedStyle.width; // clone.style.height = \'30px\';\n\n        clone.style.height = "".concat(5 + Math.random() * 80, "px"); // clone.style.filter = \'grayscale(10%)\';\n        // clone.style.filter = `brightness(1.04)`;\n\n        clone.style.overflow = \'hidden\';\n        var child = clone.firstChild;\n        child.style.position = \'absolute\';\n        child.style.top = "".concat(i * -60, "px");\n        child.style.left = \'0px\';\n        this.element.appendChild(clone);\n      }\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nGlitchAppear_defineProperty(GlitchAppear_default, "manifest", {\n  id: \'GlitchAppear\',\n  options: {\n    delay: 0\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/fx/experimental/GlitchBase.js\nfunction GlitchBase_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { GlitchBase_typeof = function _typeof(obj) { return typeof obj; }; } else { GlitchBase_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return GlitchBase_typeof(obj); }\n\nfunction GlitchBase_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction GlitchBase_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction GlitchBase_createClass(Constructor, protoProps, staticProps) { if (protoProps) GlitchBase_defineProperties(Constructor.prototype, protoProps); if (staticProps) GlitchBase_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction GlitchBase_possibleConstructorReturn(self, call) { if (call && (GlitchBase_typeof(call) === "object" || typeof call === "function")) { return call; } return GlitchBase_assertThisInitialized(self); }\n\nfunction GlitchBase_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction GlitchBase_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) GlitchBase_setPrototypeOf(subClass, superClass); }\n\nfunction GlitchBase_setPrototypeOf(o, p) { GlitchBase_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return GlitchBase_setPrototypeOf(o, p); }\n\nfunction GlitchBase_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { GlitchBase_get = Reflect.get; } else { GlitchBase_get = function _get(target, property, receiver) { var base = GlitchBase_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return GlitchBase_get(target, property, receiver || target); }\n\nfunction GlitchBase_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = GlitchBase_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction GlitchBase_getPrototypeOf(o) { GlitchBase_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return GlitchBase_getPrototypeOf(o); }\n\nfunction GlitchBase_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar GlitchBase_LOG = \'[ FX : GlitchBase ]\';\nvar GlitchBase_DEBUG = true;\n\nvar GlitchBase_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  GlitchBase_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    GlitchBase_classCallCheck(this, _default);\n\n    _this = GlitchBase_possibleConstructorReturn(this, GlitchBase_getPrototypeOf(_default).apply(this, arguments));\n    _this.original;\n    _this.computedStyle;\n    _this.segments = [];\n\n    GlitchBase_get(GlitchBase_getPrototypeOf(_default.prototype), "init", GlitchBase_assertThisInitialized(_this)).call(GlitchBase_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  GlitchBase_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      GlitchBase_DEBUG && console.log(GlitchBase_LOG, \'init()\', this.options); // Prepare elements\n\n      this.original = this.element;\n      var computedStyle = this.computedStyle = window.getComputedStyle(this.original); // Wrap everything in div\n\n      this.element = document.createElement(\'div\');\n      this.element.style.position = computedStyle.position;\n      this.element.style.width = computedStyle.width;\n      this.element.style.height = computedStyle.height; // Ignore transforms\n\n      this.element.style.top = computedStyle.top;\n      this.element.style.left = computedStyle.left;\n      this.element.style.transform = computedStyle.transform; // Incorporate transforms\n      // console.log(\'bound\', bound);\n      // this.element.style.top = bound.top+\'px\';\n      // this.element.style.left = bound.left+\'px\';\n      // this.element.style.backgroundColor = \'#BADA55\';\n      // this.element.style.overflow = \'hidden\';\n\n      this.element.setAttribute(\'mojo-fx-glitch\', this.original.getAttribute(\'mojo-fx-glitch\'));\n      this.original.removeAttribute(\'mojo-fx-glitch\');\n      this.original.style.pointerEvents = \'none\';\n      this.original.parentNode.insertBefore(this.element, this.original);\n      this.element.appendChild(this.original); // Wrap original in div (for masking etc.)\n\n      var layerWrapper = document.createElement(\'div\');\n      layerWrapper.style.pointerEvents = \'none\';\n      this.original.parentNode.insertBefore(layerWrapper, this.original);\n      layerWrapper.appendChild(this.original);\n      this.original = layerWrapper; // Generate Elements\n\n      this.generateElements();\n      console.log(GlitchBase_LOG, \'generated\');\n    }\n  }, {\n    key: "start",\n    value: function start() {}\n  }, {\n    key: "end",\n    value: function end() {}\n    /**\n     * Generate elements\n     */\n\n  }, {\n    key: "generateElements",\n    value: function generateElements() {\n      // console.log(this.computedStyle.width);\n      var seedIndex = 0,\n          top = 0,\n          i = 0;\n\n      while (true) {\n        var seed = this.options.seed[seedIndex] * this.options.factor;\n        var clone = this.original.cloneNode(true);\n        clone.classList.add(\'glitched\');\n        clone.style.position = \'absolute\';\n        clone.style.top = "".concat(top, "px");\n        clone.style.left = \'0px\';\n        clone.style.width = this.computedStyle.width; // clone.style.backgroundColor = \'DeepPink\';\n\n        clone.style.height = "".concat(seed, "px"); // clone.style.filter = \'grayscale(100%)\';\n        // clone.style.filter = `brightness(1.04)`;\n\n        clone.style.overflow = \'hidden\';\n        clone.style.pointerEvents = \'none\';\n        var child = clone.firstChild;\n        child.style.position = \'absolute\';\n        child.style.top = "-".concat(top, "px");\n        child.style.left = \'0px\';\n        child.style.transform = \'none\';\n        child.style.pointerEvents = \'none\';\n        this.segments.push(clone);\n        this.element.appendChild(clone); // End\n\n        if (top >= parseInt(this.computedStyle.height)) break; // Iterate\n        // top += seed;\n\n        top += seed - 1; // Note: We need 1px overlapping to prevent white lines when scaling (rounding issue)\n\n        seedIndex = seedIndex >= this.options.seed.length - 1 ? 0 : ++seedIndex;\n        i++;\n      }\n    }\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nGlitchBase_defineProperty(GlitchBase_default, "manifest", {\n  id: \'glitch-base\',\n  options: {\n    delay: 0,\n    seed: [1, 6, 3, 1, 3, 8, 2, 1, 9, 4, 7, 1],\n    factor: 20\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/fx/experimental/GlitchInOut.js\nfunction GlitchInOut_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { GlitchInOut_typeof = function _typeof(obj) { return typeof obj; }; } else { GlitchInOut_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return GlitchInOut_typeof(obj); }\n\nfunction GlitchInOut_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction GlitchInOut_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction GlitchInOut_createClass(Constructor, protoProps, staticProps) { if (protoProps) GlitchInOut_defineProperties(Constructor.prototype, protoProps); if (staticProps) GlitchInOut_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction GlitchInOut_possibleConstructorReturn(self, call) { if (call && (GlitchInOut_typeof(call) === "object" || typeof call === "function")) { return call; } return GlitchInOut_assertThisInitialized(self); }\n\nfunction GlitchInOut_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction GlitchInOut_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) GlitchInOut_setPrototypeOf(subClass, superClass); }\n\nfunction GlitchInOut_setPrototypeOf(o, p) { GlitchInOut_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return GlitchInOut_setPrototypeOf(o, p); }\n\nfunction GlitchInOut_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction GlitchInOut_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { GlitchInOut_get = Reflect.get; } else { GlitchInOut_get = function _get(target, property, receiver) { var base = GlitchInOut_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return GlitchInOut_get(target, property, receiver || target); }\n\nfunction GlitchInOut_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = GlitchInOut_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction GlitchInOut_getPrototypeOf(o) { GlitchInOut_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return GlitchInOut_getPrototypeOf(o); }\n\n// Experimental Effect\n\nvar GlitchInOut_LOG = \'[ FX : GlitchInOut ]\';\nvar GlitchInOut_DEBUG = false;\n\nvar GlitchInOut_default =\n/*#__PURE__*/\nfunction (_GlitchBase) {\n  GlitchInOut_inherits(_default, _GlitchBase);\n\n  function _default() {\n    var _this;\n\n    GlitchInOut_classCallCheck(this, _default);\n\n    _this = GlitchInOut_possibleConstructorReturn(this, GlitchInOut_getPrototypeOf(_default).apply(this, arguments));\n    _this.timeline;\n    return _this;\n  }\n\n  GlitchInOut_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      var _this2 = this;\n\n      GlitchInOut_get(GlitchInOut_getPrototypeOf(_default.prototype), "init", this).call(this);\n\n      GlitchInOut_DEBUG && console.log(GlitchInOut_LOG, \'init()\', this.options);\n      this.original.style.opacity = 0;\n      this.timeline = gsap.timeline({\n        paused: true,\n        delay: this.options.delay / 1000\n      });\n      this.segments.forEach(function (item, index) {\n        item.style.opacity = 0;\n        gsap.set(item, {\n          x: (Math.random() - .5) * 20 * _this2.options.power,\n          force3D: true\n        });\n\n        _this2.timeline.to(item, {\n          duration: 0.4,\n          x: 0,\n          opacity: 1,\n          ease: \'Power4.inOut\',\n          force3D: true\n        }, 0);\n      });\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      GlitchInOut_DEBUG && console.log(GlitchInOut_LOG, \'start()\');\n      this.timeline.play(); // setTimeout(()=>{\n      //   this.timeline.reverse()\n      // }, this.options.delay+1900);\n    }\n  }, {\n    key: "end",\n    value: function end() {\n      GlitchInOut_DEBUG && console.log(GlitchInOut_LOG, \'end()\');\n      this.timeline.reverse();\n    }\n  }]);\n\n  return _default;\n}(GlitchBase_default);\n\nGlitchInOut_defineProperty(GlitchInOut_default, "manifest", {\n  id: \'glitch-in-out\',\n  options: Object.assign({}, GlitchInOut_get(GlitchInOut_getPrototypeOf(GlitchInOut_default), "manifest", GlitchInOut_default).options, {\n    trigger: \'auto\',\n    delay: 0,\n    seed: [1, 6, 3, 1, 3, 8, 2, 1, 9, 4, 7, 1],\n    factor: 20,\n    power: 40\n  })\n});\n\n\n// CONCATENATED MODULE: ./src/fx/experimental/Remove.js\nfunction Remove_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Remove_typeof = function _typeof(obj) { return typeof obj; }; } else { Remove_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Remove_typeof(obj); }\n\nfunction Remove_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Remove_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Remove_createClass(Constructor, protoProps, staticProps) { if (protoProps) Remove_defineProperties(Constructor.prototype, protoProps); if (staticProps) Remove_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Remove_possibleConstructorReturn(self, call) { if (call && (Remove_typeof(call) === "object" || typeof call === "function")) { return call; } return Remove_assertThisInitialized(self); }\n\nfunction Remove_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Remove_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Remove_setPrototypeOf(subClass, superClass); }\n\nfunction Remove_setPrototypeOf(o, p) { Remove_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Remove_setPrototypeOf(o, p); }\n\nfunction Remove_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Remove_get = Reflect.get; } else { Remove_get = function _get(target, property, receiver) { var base = Remove_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Remove_get(target, property, receiver || target); }\n\nfunction Remove_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Remove_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Remove_getPrototypeOf(o) { Remove_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Remove_getPrototypeOf(o); }\n\nfunction Remove_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar Remove_LOG = \'[ FX : Remove ]\';\nvar Remove_DEBUG = true;\n\nvar Remove_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  Remove_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    Remove_classCallCheck(this, _default);\n\n    _this = Remove_possibleConstructorReturn(this, Remove_getPrototypeOf(_default).apply(this, arguments));\n\n    Remove_get(Remove_getPrototypeOf(_default.prototype), "init", Remove_assertThisInitialized(_this)).call(Remove_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  Remove_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      Remove_DEBUG && console.log(Remove_LOG, \'options:\', this.options);\n      this.element.parentElement.removeChild(this.element);\n    }\n  }, {\n    key: "start",\n    value: function start() {}\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nRemove_defineProperty(Remove_default, "manifest", {\n  id: \'remove\',\n  options: {\n    trigger: \'auto\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/fx/experimental/PanZoom.js\nfunction PanZoom_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { PanZoom_typeof = function _typeof(obj) { return typeof obj; }; } else { PanZoom_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return PanZoom_typeof(obj); }\n\nfunction PanZoom_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction PanZoom_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction PanZoom_createClass(Constructor, protoProps, staticProps) { if (protoProps) PanZoom_defineProperties(Constructor.prototype, protoProps); if (staticProps) PanZoom_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction PanZoom_possibleConstructorReturn(self, call) { if (call && (PanZoom_typeof(call) === "object" || typeof call === "function")) { return call; } return PanZoom_assertThisInitialized(self); }\n\nfunction PanZoom_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction PanZoom_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) PanZoom_setPrototypeOf(subClass, superClass); }\n\nfunction PanZoom_setPrototypeOf(o, p) { PanZoom_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return PanZoom_setPrototypeOf(o, p); }\n\nfunction PanZoom_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { PanZoom_get = Reflect.get; } else { PanZoom_get = function _get(target, property, receiver) { var base = PanZoom_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return PanZoom_get(target, property, receiver || target); }\n\nfunction PanZoom_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = PanZoom_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction PanZoom_getPrototypeOf(o) { PanZoom_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return PanZoom_getPrototypeOf(o); }\n\nfunction PanZoom_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Experimental Effect\n\nvar PanZoom_LOG = \'[ FX : PanZoom ]\';\nvar PanZoom_DEBUG = true;\n\nvar PanZoom_default =\n/*#__PURE__*/\nfunction (_FxBase) {\n  PanZoom_inherits(_default, _FxBase);\n\n  function _default() {\n    var _this;\n\n    PanZoom_classCallCheck(this, _default);\n\n    _this = PanZoom_possibleConstructorReturn(this, PanZoom_getPrototypeOf(_default).apply(this, arguments));\n\n    PanZoom_get(PanZoom_getPrototypeOf(_default.prototype), "init", PanZoom_assertThisInitialized(_this)).call(PanZoom_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  PanZoom_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      var _this2 = this;\n\n      console.log(PanZoom_LOG, \'options:\', this.options); // TEMP: XD HACK\n\n      this.element.parentNode.style.overflow = \'hidden\';\n      this.element.parentNode.style.border = \'1px solid black\'; // Get stops\n\n      var stopElements = this.element.querySelectorAll(\'[mojo-fx-panzoom-stop]\');\n      PanZoom_DEBUG && console.log(PanZoom_LOG, \'stopElements:\', stopElements); // Process stops\n\n      this.stops = [];\n      stopElements.forEach(function (item) {\n        var stop = {\n          el: item,\n          scale: _this2.element.offsetWidth / item.offsetWidth,\n          left: parseInt(window.getComputedStyle(item).transform.split(\'(\')[1].split(\',\')[4]),\n          top: parseInt(window.getComputedStyle(item).transform.split(\'(\')[1].split(\',\')[5])\n        };\n\n        _this2.stops.push(stop);\n\n        item.style.opacity = 0;\n        item.style.pointerEvents = \'none\';\n      });\n      PanZoom_DEBUG && console.log(PanZoom_LOG, \'stops:\', this.stops);\n    }\n  }, {\n    key: "start",\n    value: function start() {\n      var _this3 = this;\n\n      this.timeline = gsap.timeline();\n      this.stops.forEach(function (item) {\n        _this3.timeline.to(_this3.element, {\n          scale: item.scale,\n          x: -item.left * item.scale,\n          y: -item.top * item.scale,\n          transformOrigin: \'0 0\',\n          delay: .5,\n          duration: 1\n        });\n      });\n    }\n  }, {\n    key: "end",\n    value: function end() {}\n  }]);\n\n  return _default;\n}(FxBase["a" /* default */]);\n\nPanZoom_defineProperty(PanZoom_default, "manifest", {\n  id: \'panzoom\',\n  options: {\n    trigger: \'auto\'\n  }\n});\n\n\n// CONCATENATED MODULE: ./src/plugins/PluginBase.js\nfunction PluginBase_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { PluginBase_typeof = function _typeof(obj) { return typeof obj; }; } else { PluginBase_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return PluginBase_typeof(obj); }\n\nfunction PluginBase_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction PluginBase_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction PluginBase_createClass(Constructor, protoProps, staticProps) { if (protoProps) PluginBase_defineProperties(Constructor.prototype, protoProps); if (staticProps) PluginBase_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction PluginBase_possibleConstructorReturn(self, call) { if (call && (PluginBase_typeof(call) === "object" || typeof call === "function")) { return call; } return PluginBase_assertThisInitialized(self); }\n\nfunction PluginBase_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction PluginBase_getPrototypeOf(o) { PluginBase_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return PluginBase_getPrototypeOf(o); }\n\nfunction PluginBase_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) PluginBase_setPrototypeOf(subClass, superClass); }\n\nfunction PluginBase_setPrototypeOf(o, p) { PluginBase_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return PluginBase_setPrototypeOf(o, p); }\n\n\nvar PluginBase_LOG = \'[ PluginBase ]\';\nvar PluginBase_DEBUG = true;\n\nvar PluginBase_default =\n/*#__PURE__*/\nfunction (_NanoEvents) {\n  PluginBase_inherits(_default, _NanoEvents);\n\n  function _default(scene, options) {\n    var _this;\n\n    PluginBase_classCallCheck(this, _default);\n\n    _this = PluginBase_possibleConstructorReturn(this, PluginBase_getPrototypeOf(_default).call(this));\n    _this.scene = scene;\n    _this.player = scene.player;\n    _this.options = options;\n    return _this;\n  }\n\n  PluginBase_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      this.options = Object.assign(this.manifest.options, this.options);\n      this.init();\n    }\n  }]);\n\n  return _default;\n}(nanoevents["a" /* default */]);\n\n\n// CONCATENATED MODULE: ./src/plugins/wip/VisualDebugger.js\nfunction VisualDebugger_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { VisualDebugger_typeof = function _typeof(obj) { return typeof obj; }; } else { VisualDebugger_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return VisualDebugger_typeof(obj); }\n\nfunction VisualDebugger_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction VisualDebugger_possibleConstructorReturn(self, call) { if (call && (VisualDebugger_typeof(call) === "object" || typeof call === "function")) { return call; } return VisualDebugger_assertThisInitialized(self); }\n\nfunction VisualDebugger_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction VisualDebugger_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction VisualDebugger_createClass(Constructor, protoProps, staticProps) { if (protoProps) VisualDebugger_defineProperties(Constructor.prototype, protoProps); if (staticProps) VisualDebugger_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction VisualDebugger_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) VisualDebugger_setPrototypeOf(subClass, superClass); }\n\nfunction VisualDebugger_setPrototypeOf(o, p) { VisualDebugger_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return VisualDebugger_setPrototypeOf(o, p); }\n\nfunction VisualDebugger_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { VisualDebugger_get = Reflect.get; } else { VisualDebugger_get = function _get(target, property, receiver) { var base = VisualDebugger_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return VisualDebugger_get(target, property, receiver || target); }\n\nfunction VisualDebugger_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = VisualDebugger_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction VisualDebugger_getPrototypeOf(o) { VisualDebugger_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return VisualDebugger_getPrototypeOf(o); }\n\n// Experimental Plugin\n\n\nvar VisualDebugger_LOG = \'[ Plugin : VisualDebugger ]\';\nvar VisualDebugger_DEBUG = false;\n\nvar VisualDebugger_default =\n/*#__PURE__*/\nfunction (_PluginBase) {\n  VisualDebugger_inherits(_default, _PluginBase);\n\n  VisualDebugger_createClass(_default, null, [{\n    key: "manifest",\n    value: function manifest() {\n      return {\n        id: \'visualDebugger\',\n        options: {}\n      };\n    }\n  }]);\n\n  function _default() {\n    var _this;\n\n    VisualDebugger_classCallCheck(this, _default);\n\n    _this = VisualDebugger_possibleConstructorReturn(this, VisualDebugger_getPrototypeOf(_default).apply(this, arguments));\n    _this.manifest = _this.constructor.manifest();\n\n    VisualDebugger_get(VisualDebugger_getPrototypeOf(_default.prototype), "init", VisualDebugger_assertThisInitialized(_this)).call(VisualDebugger_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  VisualDebugger_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      VisualDebugger_DEBUG && console.log(VisualDebugger_LOG, \'init()\');\n      this.scene.on(Const.SCENE_PRE_READY, this.on_scene_preReady.bind(this));\n      this.scene.on(Const.SCENE_READY, this.on_scene_ready.bind(this));\n    }\n    /**\n     * on_scene_preReady\n     */\n\n  }, {\n    key: "on_scene_preReady",\n    value: function on_scene_preReady() {}\n    /**\n     * on_scene_ready\n     */\n\n  }, {\n    key: "on_scene_ready",\n    value: function on_scene_ready() {\n      var clone = this.scene.content.cloneNode(false);\n      clone.setAttribute(\'style\', this.scene.content.getAttribute(\'style\'));\n      clone.style.border = \'1px solid rgba(0,0,0,.2)\';\n      clone.style.boxSizing = \'border-box\';\n      clone.style.pointerEvents = \'none\';\n      this.scene.content.parentNode.appendChild(clone);\n    }\n  }]);\n\n  return _default;\n}(PluginBase_default);\n\n\n// CONCATENATED MODULE: ./src/plugins/wip/Panorama.js\nfunction Panorama_typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Panorama_typeof = function _typeof(obj) { return typeof obj; }; } else { Panorama_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Panorama_typeof(obj); }\n\nfunction Panorama_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Panorama_possibleConstructorReturn(self, call) { if (call && (Panorama_typeof(call) === "object" || typeof call === "function")) { return call; } return Panorama_assertThisInitialized(self); }\n\nfunction Panorama_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Panorama_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Panorama_createClass(Constructor, protoProps, staticProps) { if (protoProps) Panorama_defineProperties(Constructor.prototype, protoProps); if (staticProps) Panorama_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction Panorama_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Panorama_setPrototypeOf(subClass, superClass); }\n\nfunction Panorama_setPrototypeOf(o, p) { Panorama_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Panorama_setPrototypeOf(o, p); }\n\nfunction Panorama_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { Panorama_get = Reflect.get; } else { Panorama_get = function _get(target, property, receiver) { var base = Panorama_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return Panorama_get(target, property, receiver || target); }\n\nfunction Panorama_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Panorama_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Panorama_getPrototypeOf(o) { Panorama_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Panorama_getPrototypeOf(o); }\n\n// Experimental Plugin\n\n\nvar Panorama_LOG = \'[ Plugin : Panorama ]\';\nvar Panorama_DEBUG = true;\n\nvar Panorama_default =\n/*#__PURE__*/\nfunction (_PluginBase) {\n  Panorama_inherits(_default, _PluginBase);\n\n  Panorama_createClass(_default, null, [{\n    key: "manifest",\n    value: function manifest() {\n      return {\n        id: \'panorama\',\n        options: {\n          speed: 1\n        }\n      };\n    }\n  }]);\n\n  function _default() {\n    var _this;\n\n    Panorama_classCallCheck(this, _default);\n\n    _this = Panorama_possibleConstructorReturn(this, Panorama_getPrototypeOf(_default).apply(this, arguments));\n    _this.manifest = _this.constructor.manifest();\n\n    Panorama_get(Panorama_getPrototypeOf(_default.prototype), "init", Panorama_assertThisInitialized(_this)).call(Panorama_assertThisInitialized(_this));\n\n    _this.mouseX;\n    _this.lastScrollTo = 0;\n    return _this;\n  }\n\n  Panorama_createClass(_default, [{\n    key: "init",\n    value: function init() {\n      Panorama_DEBUG && console.log(Panorama_LOG, \'init()\');\n      this.scene.on(Const.SCENE_PRE_READY, this.on_scene_preReady.bind(this));\n      this.scene.on(Const.SCENE_READY, this.on_scene_ready.bind(this));\n    }\n    /**\n     * on_scene_preReady\n     */\n\n  }, {\n    key: "on_scene_preReady",\n    value: function on_scene_preReady() {\n      // Prepare scene\n      this.scene.element.style.overflowX = \'scroll\';\n      this.scene.content.style.overflow = \'unset\'; // // Tweak content container to get real width\n      // // scene.content.style.width = \'auto\';\n      // scene.content.style.right = \'unset\';\n      // // Prevent history back when scrolling to left on viewport\n      // // #TODO: Not preventing in Edge\n      // scene.element.addEventListener(\'mousewheel\', function(evt) {\n      //   if (evt.currentTarget.scrollLeft <= 0 && evt.deltaX < 0)  evt.preventDefault();\n      // }, {passive: false});\n      // #TODO: DECIDE ON THROTTLE\n\n      this.scene.element.addEventListener(\'mousemove\', mojo.FusionHelper.throttle(this.on_scene_mouseMove.bind(this), 50)); // 20fps\n\n      this.scene.element.addEventListener(\'click\', this.on_scene_click.bind(this));\n    }\n    /**\n     * on_scene_ready\n     */\n\n  }, {\n    key: "on_scene_ready",\n    value: function on_scene_ready() {\n      Panorama_DEBUG && console.log(Panorama_LOG, \'on_scene_ready()\');\n    }\n    /**\n     * on_scene_mouseMove\n     */\n\n  }, {\n    key: "on_scene_mouseMove",\n    value: function on_scene_mouseMove(evt) {\n      this.mouseX = evt.clientX - this.scene.element.getBoundingClientRect().left;\n    }\n    /**\n     * on_scene_click\n     */\n\n  }, {\n    key: "on_scene_click",\n    value: function on_scene_click(evt) {\n      // Bail if mouse is on interactive elements\n      if (evt.target.hasAttribute(\'mojo-interactive\')) return; // Bail if already moving/scrolling\n\n      if (gsap.isTweening(this.scene.element)) return;\n      var scene = this.scene; // Determine direction\n\n      var minScrollTo = 0;\n      var maxScrollTo = Math.round(scene.content.scrollWidth * scene.scale - scene.element.clientWidth);\n      var dir = this.mouseX - scene.element.clientWidth / 2 > 0 ? \'right\' : \'left\';\n      dir = scene.element.scrollLeft <= minScrollTo ? \'right\' : dir;\n      dir = scene.element.scrollLeft >= maxScrollTo ? \'left\' : dir;\n      Panorama_DEBUG && console.log(Panorama_LOG, \'dir:\', dir); //---\n      // step = scene width\n      // var currentIndex = Math.round(scene.element.scrollLeft/(scene.data.width * scene.scale));\n      // var scrollTo = ((dir==\'left\') ? currentIndex-1 : currentIndex+1) * (scene.data.width * scene.scale);\n      // scrollTo = (scrollTo <= minScrollTo) ? \'0\' : scrollTo;\n      // scrollTo = (scrollTo > maxScrollTo) ? maxScrollTo : scrollTo;\n      //---\n      // step = custom stops\n\n      var stops = this.options.stops;\n      if (!stops) console.error(Panorama_LOG, \'missing options "stops"\');\n      stops = stops.map(function (x) {\n        return Math.round(x * scene.scale);\n      });\n      stops.sort(function (a, b) {\n        return a - b;\n      });\n      Panorama_DEBUG && console.log(Panorama_LOG, \'stops\', stops);\n      var currentScrollCenter = Math.round(scene.element.scrollLeft + scene.element.clientWidth / 2 - (scene.element.clientWidth - scene.content.clientWidth * scene.scale) / 2); // DEBUG && console.log(LOG, \'currentScrollCenter\', currentScrollCenter);\n\n      var scrollTo;\n      var stop = 0;\n\n      if (dir == \'left\') {\n        // Find next smaller stop (relative to current scroll center)\n        var stopsReverse = stops.slice(0).reverse();\n\n        for (var i = 0; i < stopsReverse.length; i++) {\n          var item = stopsReverse[i];\n\n          if (item < currentScrollCenter) {\n            stop = item;\n            break;\n          }\n        }\n      } else {\n        // Find next higher stop (relative to current scroll center)\n        for (var i = 0; i < stops.length; i++) {\n          var item = stops[i];\n\n          if (item > currentScrollCenter + 1) {\n            stop = item;\n            break;\n          }\n        }\n      } // Calculate scroll new position\n\n\n      scrollTo = Math.floor(stop - scene.element.clientWidth / 2 + (scene.element.clientWidth - scene.content.clientWidth * scene.scale) / 2);\n      scrollTo = scrollTo <= minScrollTo ? \'0\' : scrollTo;\n      scrollTo = scrollTo > maxScrollTo ? maxScrollTo : scrollTo; // DEBUG && console.log(LOG, \'scrollTo\', scrollTo);\n      // Duration relative to distance\n\n      var duration = Math.abs(this.lastScrollTo - scrollTo) / 1200 / this.options.speed;\n      duration = duration < .2 ? .2 : duration; // DEBUG && console.log(LOG, \'speed\', this.options.speed);\n      // DEBUG && console.log(LOG, \'duration\', duration);\n      // Remember\n\n      this.lastScrollTo = scrollTo; // Tween    \n\n      gsap.isTweening(scene.element) && gsap.killTweensOf(scene.element);\n      gsap.to(scene.element, {\n        duration: duration,\n        ease: \'power4.inOut\',\n        scrollLeft: scrollTo,\n        onComplete: function onComplete() {\n          // updateCursorDir();\n          // Propagate custom_slide_active\n          scene.emit(\'custom_slide_active\', {\n            index: stops.indexOf(stop),\n            scrollTo: scrollTo\n          });\n        }\n      });\n    }\n  }]);\n\n  return _default;\n}(PluginBase_default);\n\n\n// EXTERNAL MODULE: ./style/fusion.scss\nvar fusion = __webpack_require__(6);\n\n// CONCATENATED MODULE: ./src/MojoFusion.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n // Gsap Defaults\n\ngsap.defaults({\n  ease: "power2.inOut",\n  duration: 0.5\n});\ngsap.config({\n  force3D: true\n}); // Global Mojo instance\n\nwindow.mojo = new Mojo_default(); // Use Mojo instance as namespace for all classes\n\nObject.assign(window.mojo, {\n  MojoFusionPlayer: MojoFusionPlayer_default,\n  FusionHelper: FusionHelper,\n  // #TODO: Decide between FusionHelper.throttle and helper.throttle (lodash)\n  helper: {\n    throttle: lodash_throttle_default.a,\n    debounce: lodash_debounce_default.a\n  },\n  "const": Const,\n  plugins: {\n    Panorama: Panorama_default,\n    VisualDebugger: VisualDebugger_default\n  },\n  fx: {\n    FxBase: FxBase["a" /* default */],\n    Debugger: Debugger_default,\n    FxScanner: FxScanner["a" /* default */],\n    Magnet: Magnet_default,\n    Particles: Particles_default,\n    HandCursor: HandCursor_default,\n    Jump: Jump_default,\n    Glitch: Glitch_default,\n    GlitchAppear: GlitchAppear_default,\n    GlitchInOut: GlitchInOut_default,\n    GlitchCanvas: GlitchCanvas_default,\n    GlitchEasel: GlitchEasel_default,\n    TypeAnimation: TypeAnimation_default,\n    Spritesheet: Spritesheet_default,\n    Remove: Remove_default,\n    PanZoom: PanZoom_default,\n    ex: {\n      anime: {\n        Magnet: anime_Magnet_default\n      }\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9CcmFpbi5qcz8yNTA2Iiwid2VicGFjazovLy8uL3NyYy9jb3JlL01vam8uanM/ZjBjZSIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9GdXNpb25IZWxwZXIuanM/NjhlYyIsIndlYnBhY2s6Ly8vLi9zcmMvQ29uc3QuanM/YzM1OCIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9GdXNpb25TY2VuZURlYnVnZ2VyLmpzPzRkNWYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvcmUvRnVzaW9uU2NlbmUuanM/NDI2MiIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS9GdXNpb25TY2VuZUlmcmFtZS5qcz9lNDBiIiwid2VicGFjazovLy8uL3NyYy9jb3JlL0Z1c2lvblNjZW5lRGVmYXVsdC5qcz9hZjU5Iiwid2VicGFjazovLy8uL3NyYy9jb3JlL01vam9GdXNpb25QbGF5ZXIuanM/YzVkZSIsIndlYnBhY2s6Ly8vLi9zcmMvZngvZXhwZXJpbWVudGFsL01hZ25ldC5qcz9hYWZjIiwid2VicGFjazovLy8uL3NyYy9meC9leHBlcmltZW50YWwvYW5pbWUvTWFnbmV0LmpzP2E4ODIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Z4L2V4cGVyaW1lbnRhbC9UeXBlQW5pbWF0aW9uLmpzPzJkN2QiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Z4L2V4cGVyaW1lbnRhbC9QYXJ0aWNsZXMuanM/NzQyYiIsIndlYnBhY2s6Ly8vLi9zcmMvZngvZXhwZXJpbWVudGFsL1Nwcml0ZXNoZWV0LmpzP2Y4YzEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Z4L2V4cGVyaW1lbnRhbC9KdW1wLmpzPzBjYmEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Z4L2V4cGVyaW1lbnRhbC9IYW5kQ3Vyc29yLmpzP2E2OGMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Z4L2V4cGVyaW1lbnRhbC9HbGl0Y2guanM/YzJiMCIsIndlYnBhY2s6Ly8vLi9zcmMvZngvZXhwZXJpbWVudGFsL0RlYnVnZ2VyLmpzPzA1Y2EiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Z4L2V4cGVyaW1lbnRhbC9HbGl0Y2hDYW52YXMuanM/YjE5NyIsIndlYnBhY2s6Ly8vLi9zcmMvZngvZXhwZXJpbWVudGFsL0dsaXRjaEVhc2VsLmpzP2MzZTAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Z4L2V4cGVyaW1lbnRhbC9HbGl0Y2hBcHBlYXIuanM/N2NlYiIsIndlYnBhY2s6Ly8vLi9zcmMvZngvZXhwZXJpbWVudGFsL0dsaXRjaEJhc2UuanM/OTc4YyIsIndlYnBhY2s6Ly8vLi9zcmMvZngvZXhwZXJpbWVudGFsL0dsaXRjaEluT3V0LmpzPzJiZmQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2Z4L2V4cGVyaW1lbnRhbC9SZW1vdmUuanM/YzBiNyIsIndlYnBhY2s6Ly8vLi9zcmMvZngvZXhwZXJpbWVudGFsL1Bhblpvb20uanM/MzRmZiIsIndlYnBhY2s6Ly8vLi9zcmMvcGx1Z2lucy9QbHVnaW5CYXNlLmpzPzU1YWEiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BsdWdpbnMvd2lwL1Zpc3VhbERlYnVnZ2VyLmpzPzljNjQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BsdWdpbnMvd2lwL1Bhbm9yYW1hLmpzPzI0ZTYiLCJ3ZWJwYWNrOi8vLy4vc3JjL01vam9GdXNpb24uanM/YmNkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBMT0cgPSAnWyBCcmFpbiBdJztcbnZhciBERUJVRyA9IHRydWU7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdjb25zdHJ1Y3RvcigpJyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQocCkge1xuICAgICAgY29uc29sZS5sb2coTE9HLCAnYWRkKCkgcDonLCBwKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KCk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmltcG9ydCBCcmFpbiBmcm9tICcuL0JyYWluJztcbmltcG9ydCBGeEJhc2UgZnJvbSAnLi4vZngvRnhCYXNlJztcbnZhciBMT0cgPSAnWyBNb2pvIF0nO1xudmFyIERFQlVHID0gZmFsc2U7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJyYWluXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLmJyYWluID0gbmV3IEJyYWluKCk7XG4gICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnY29uc3RydWN0b3IoKScpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRcbiAgICogRm9yIHBhcmFtZXRlcnMgYWxzbyBzZWUgYWRkQmVoYXZpb3IoKVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZCgpIHtcbiAgICAgIC8vIERlbGVnYXRlIGRlcGVuZGluZyBvbiBzaWduYXR1cmVcbiAgICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBFbGVtZW50ICYmICh0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnc3RyaW5nJyB8fCBfdHlwZW9mKGFyZ3VtZW50c1sxXSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBhcmd1bWVudHNbMV0udHlwZSA9PT0gJ3N0cmluZycpICYmIGFyZ3VtZW50c1syXS5wcm90b3R5cGUgaW5zdGFuY2VvZiBtb2pvLmZ4LkZ4QmFzZSkge1xuICAgICAgICB0aGlzLmFkZEJlaGF2aW9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBiZWhhdmlvclxuICAgICAqIChzdXBwb3J0cyBhdXRvbWF0aWMgYXJlYSBkZXRlY3Rpb246IGlmIG5leHQgbm9kZSBoYXMgYXR0cmlidXRlIFwibW9qby10cmlnZ2VyLWFyZWFcIiApXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgVGhlIGhvc3QgZWxlbWVudCB0byBhZGQgdGhlIGJlaGF2aW9yIHRvXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfG9iamVjdCl9IHRyaWdnZXIgVGhlIHRyaWdnZXIgdHlwZSAoZS5nLiBjbGljaywgaG92ZXIsIHRvZ2dsZSBldGMuKVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEUuZy4gJ2NsaWNrJyBvciB7dHlwZTogJ2hvdmVyJywgYXJlYTogJyNjdXN0b20tdHJpZ2dlci1hcmVhJ31cbiAgICAgKiBAcGFyYW0ge0Z4QmFzZX0gRnggVGhlIGVmZmVjdCBjbGFzcyB0byBhcHBseSAoZS5nLiBtb2pvLmZ4Lk1hZ25ldClcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2Z4T3B0aW9uc10gT3B0aW9uYWwgZWZmZWN0IG9wdGlvbnMgKGUuZyB7c3BlZWQ6IDJ9KVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQmVoYXZpb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQmVoYXZpb3IoZWwsIHRyaWdnZXIsIEZ4LCBmeE9wdGlvbnMpIHtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2FkZEJlaGF2aW9yKCknLCBlbCwgdHJpZ2dlcik7XG4gICAgICB2YXIgdHJpZ2dlclR5cGUgPSB0eXBlb2YgdHJpZ2dlciA9PT0gJ3N0cmluZycgPyB0cmlnZ2VyIDogdHJpZ2dlci50eXBlLFxuICAgICAgICAgIC8vIGFyZWEgPSAodHlwZW9mKHRyaWdnZXIpID09PSAnc3RyaW5nJykgPyBlbCA6ICh0eXBlb2YodHJpZ2dlci5hcmVhKSA9PT0gJ3N0cmluZycpID8gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0cmlnZ2VyLmFyZWEpIDogdHJpZ2dlci5hcmVhLFxuICAgICAgc3RhbmRhcmQgPSB0cnVlLFxuICAgICAgICAgIHN0YXJ0VHJpZ2dlcixcbiAgICAgICAgICBlbmRUcmlnZ2VyOyAvLy0tLVxuICAgICAgLy8gQ3JlYXRlIGZ4XG5cbiAgICAgIGZ4T3B0aW9ucyA9IGZ4T3B0aW9ucyA/IGZ4T3B0aW9ucyA6IHt9O1xuICAgICAgdmFyIGZ4ID0gbmV3IEZ4KGVsLCBmeE9wdGlvbnMpO1xuICAgICAgZWwgPSBmeC5lbGVtZW50OyAvLy0tLVxuICAgICAgLy8gQXJlYVxuXG4gICAgICB2YXIgYXJlYSA9IHR5cGVvZiB0cmlnZ2VyID09PSAnc3RyaW5nJyA/IGVsIDogdHlwZW9mIHRyaWdnZXIuYXJlYSA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRyaWdnZXIuYXJlYSkgOiB0cmlnZ2VyLmFyZWE7XG5cbiAgICAgIGlmIChhcmVhID09IGVsKSB7XG4gICAgICAgIC8vIEF1dG8gZGV0ZWN0IGFyZWEgKG5leHQgbm9kZSBoYXMgXCJtb2pvLXRyaWdnZXItYXJlYVwiIGF0dHJpYnV0ZSlcbiAgICAgICAgaWYgKGVsLm5leHRFbGVtZW50U2libGluZyAmJiBlbC5uZXh0RWxlbWVudFNpYmxpbmcuaGFzQXR0cmlidXRlKCdtb2pvLXRyaWdnZXItYXJlYScpKSB7XG4gICAgICAgICAgaWYgKGVsLm5leHRFbGVtZW50U2libGluZy50YWdOYW1lID09ICdzdmcnKSB7XG4gICAgICAgICAgICBhcmVhID0gZWwubmV4dEVsZW1lbnRTaWJsaW5nLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBlbC5uZXh0RWxlbWVudFNpYmxpbmcuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJlYSA9IGVsLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgICB9IC8vLS0tXG4gICAgICAvLyBUcmlnZ2VyIHR5cGVcblxuXG4gICAgICBzd2l0Y2ggKHRyaWdnZXJUeXBlKSB7XG4gICAgICAgIGNhc2UgJyc6XG4gICAgICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgICAgIHN0YW5kYXJkID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2xpY2snOlxuICAgICAgICAgIHN0YXJ0VHJpZ2dlciA9ICdjbGljayc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaG92ZXInOlxuICAgICAgICAgIHN0YXJ0VHJpZ2dlciA9ICdtb3VzZWVudGVyJztcbiAgICAgICAgICBlbmRUcmlnZ2VyID0gJ21vdXNlbGVhdmUnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RvZ2dsZSc6XG4gICAgICAgICAgc3RhcnRUcmlnZ2VyID0gJ2NsaWNrJztcbiAgICAgICAgICBlbmRUcmlnZ2VyID0gJ2NsaWNrJztcbiAgICAgICAgICBzdGFuZGFyZCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfSAvLy0tLVxuICAgICAgLy8gU2V0dXAgdHJpZ2dlcmluZyAoZXZlbnQgbGlzdGVuZXJzIGV0Yy4pXG5cblxuICAgICAgaWYgKHN0YW5kYXJkKSB7XG4gICAgICAgIHN0YXJ0VHJpZ2dlciAmJiBhcmVhLmFkZEV2ZW50TGlzdGVuZXIoc3RhcnRUcmlnZ2VyLCBmeC5zdGFydC5iaW5kKGZ4KSk7XG4gICAgICAgIGVuZFRyaWdnZXIgJiYgYXJlYS5hZGRFdmVudExpc3RlbmVyKGVuZFRyaWdnZXIsIGZ4LmVuZC5iaW5kKGZ4KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKHRyaWdnZXJUeXBlKSB7XG4gICAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgICBjYXNlICdhdXRvJzpcbiAgICAgICAgICAgIGZ4LnN0YXJ0KCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3RvZ2dsZSc6XG4gICAgICAgICAgICB2YXIgb24gPSB0cnVlO1xuICAgICAgICAgICAgYXJlYS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgb24gPyBmeC5zdGFydCgpIDogZnguZW5kKCk7XG4gICAgICAgICAgICAgIG9uID0gIW9uO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLy0tLVxuICAgICAgLy8gTWVtb3JpemUgb24gZWxlbWVudCBsZXZlbCBpZiBmeCBoYXMgaWRcblxuXG4gICAgICBpZiAoZnhPcHRpb25zLmlkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdNZW1vcml6ZSBvbiBlbGVtZW50IHdpdGggaWQ6JywgZnhPcHRpb25zLmlkKTtcbiAgICAgICAgdGhpcy5wcmVwYXJlRWxlbWVudChlbCk7XG4gICAgICAgIGVsLm1vam8uZngucHVzaChmeCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgZWxlbWVudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicHJlcGFyZUVsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyZUVsZW1lbnQoZWwpIHtcbiAgICAgICFlbC5tb2pvICYmIChlbC5tb2pvID0ge1xuICAgICAgICBmeDogW11cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oKTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZXhwb3J0IHZhciBGdXNpb25IZWxwZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGdXNpb25IZWxwZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZ1c2lvbkhlbHBlcik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRnVzaW9uSGVscGVyLCBudWxsLCBbe1xuICAgIGtleTogXCJhcHBlbmRIdG1sXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZEh0bWwodGFyZ2V0LCBtYXJrdXApIHtcbiAgICAgIHRhcmdldC5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIG1hcmt1cCk7XG4gICAgICByZXR1cm4gdGFyZ2V0Lmxhc3RDaGlsZDtcbiAgICB9IC8vLS0tXG4gICAgLy8gREVQUkVDQVRFRCAhISEhICh1c2UgbW9qby5oZWxwZXIudGhyb3R0bGUgZXRjLilcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbS1nYWduZS9saW1pdC5qc1xuICAgIC8vIChzbGlnaHRseSBtb2RpZmllZClcblxuICB9LCB7XG4gICAga2V5OiBcImRlYm91bmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIG1pbGxpc2Vjb25kcywgY29udGV4dCkge1xuICAgICAgdmFyIGJhc2VGdW5jdGlvbiA9IGZ1bmMsXG4gICAgICAgICAgdGltZXIgPSBudWxsLFxuICAgICAgICAgIHdhaXQgPSBtaWxsaXNlY29uZHM7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IGNvbnRleHQgfHwgZnVuYyxcbiAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICAgICAgYmFzZUZ1bmN0aW9uLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoY29tcGxldGUsIHdhaXQpO1xuICAgICAgfTtcbiAgICB9IC8vLS0tXG4gICAgLy8gREVQUkVDQVRFRCAhISEhICh1c2UgbW9qby5oZWxwZXIudGhyb3R0bGUgZXRjLilcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbS1nYWduZS9saW1pdC5qc1xuICAgIC8vIChzbGlnaHRseSBtb2RpZmllZClcblxuICB9LCB7XG4gICAga2V5OiBcInRocm90dGxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIG1pbGxpc2Vjb25kcywgY29udGV4dCkge1xuICAgICAgdmFyIGJhc2VGdW5jdGlvbiA9IGZ1bmMsXG4gICAgICAgICAgbGFzdEV2ZW50VGltZXN0YW1wID0gbnVsbCxcbiAgICAgICAgICBsaW1pdCA9IG1pbGxpc2Vjb25kcyxcbiAgICAgICAgICB0aW1lb3V0LFxuICAgICAgICAgIGxhc3RDdXJyZW50VGFyZ2V0O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSBjb250ZXh0IHx8IGZ1bmMsXG4gICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgICAgICBpZiAoIWxhc3RFdmVudFRpbWVzdGFtcCB8fCBub3cgLSBsYXN0RXZlbnRUaW1lc3RhbXAgPj0gbGltaXQpIHtcbiAgICAgICAgICBsYXN0RXZlbnRUaW1lc3RhbXAgPSBub3c7XG4gICAgICAgICAgYmFzZUZ1bmN0aW9uLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICAgICAgaWYgKGFyZ3NbMF0gaW5zdGFuY2VvZiBFdmVudCkge1xuICAgICAgICAgICAgbGFzdEN1cnJlbnRUYXJnZXQgPSBhcmdzWzBdLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgRXZlbnQpIHtcbiAgICAgICAgICAgIGFyZ3NbMF0uY3VycmVudFRhcmdldF8gPSBsYXN0Q3VycmVudFRhcmdldDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBiYXNlRnVuY3Rpb24uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgfSwgbWlsbGlzZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgLyohXG4gICAgICogQ2hlY2sgaWYgYW4gZWxlbWVudCBpcyBpbnNpZGUgdGhlIHZpZXdwb3J0XG4gICAgICogI1RPRE8gQ29uc2lkZXI6XG4gICAgICogICArIGNhY2hpbmdcbiAgICAgKiAgICsgcGFydGlhbGx5IGluIHZpZXdwb3J0XG4gICAgICogICArIG5vdCByZWxhdGl2ZSB0byB3aW5kb3cgYnV0IHRvIHBhcmVudCBjb250YWluZXJcbiAgICAgKiAjUEVSRk9STUFOQ0UgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgbWlnaHQgYmVjb21lIGEgcGVyZm9ybWFuY2UgYm90dGxlbmVja1xuICAgICAqICAgICAgICAgICAgICBzZWUgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzVkNTJmYjA4MWIzNTcwYzgxZTNhXG4gICAgICogICAgICAgICAgICAgIGFuZCBodHRwczovL2dpdGh1Yi5jb20vcGVsb3RvbmN5Y2xlL3Jlc2l6ZS1vYnNlcnZlci9pc3N1ZXMvNVxuICAgICAqIEBwYXJhbSAge05vZGV9IGVsIFRoZSBlbGVtZW50XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGVsZW1lbnQgaXMgaW4gdGhlIHZpZXdwb3J0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpc0luVmlld3BvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJblZpZXdwb3J0KGVsKSB7XG4gICAgICB2YXIgZGlzdGFuY2UgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHJldHVybiBkaXN0YW5jZS50b3AgPj0gMCAmJiBkaXN0YW5jZS5sZWZ0ID49IDAgJiYgZGlzdGFuY2UuYm90dG9tIDw9ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkgJiYgZGlzdGFuY2UucmlnaHQgPD0gKHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZ1c2lvbkhlbHBlcjtcbn0oKTsiLCJleHBvcnQgZGVmYXVsdCB7XG4gIFNDRU5FX1BMVUdJTlNfUkVBRFk6ICdTQ0VORV9QTFVHSU5TX1JFQURZJyxcbiAgU0NFTkVfUFJFX1JFQURZOiAnU0NFTkVfUFJFX1JFQURZJyxcbiAgU0NFTkVfUkVBRFk6ICdTQ0VORV9SRUFEWSdcbn07IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5pbXBvcnQgeyBGdXNpb25IZWxwZXIgfSBmcm9tICcuL0Z1c2lvbkhlbHBlcic7XG5pbXBvcnQgQ29uc3QgZnJvbSAnLi4vQ29uc3QnO1xudmFyIExPRyA9ICdbIEZ1c2lvblNjZW5lRGVidWdnZXIgXSc7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIF9kZWZhdWx0KHNjZW5lKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgY29uc29sZS5sb2coTE9HLCAnY29uc3RydWN0b3IoKScsIHNjZW5lKTtcbiAgICBzY2VuZS5vbihDb25zdC5TQ0VORV9QUkVfUkVBRFksIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmd1aWRlc1dyYXBwZXIgPSBGdXNpb25IZWxwZXIuYXBwZW5kSHRtbChzY2VuZS5lbGVtZW50LnBhcmVudE5vZGUsIFwiPGRpdiBjbGFzcz1cXFwiZnVzaW9uLS1zY2VuZS0tZGVidWdnZXItLWd1aWRlc1dyYXBwZXJcXFwiPjwvZGl2PlwiKTtcbiAgICAgIDtcbiAgICAgIF90aGlzLmd1aWRlSG9yaXpvbnRhbENlbnRlciA9IEZ1c2lvbkhlbHBlci5hcHBlbmRIdG1sKF90aGlzLmd1aWRlc1dyYXBwZXIsIFwiPGRpdiBjbGFzcz1cXFwiZ3VpZGUtaG9yaXpvbnRhbC1jZW50ZXJcXFwiPjwvZGl2PlwiKTtcbiAgICAgIDtcbiAgICAgIF90aGlzLmd1aWRlU2NlbmVCb3VuZHMgPSBGdXNpb25IZWxwZXIuYXBwZW5kSHRtbChfdGhpcy5ndWlkZXNXcmFwcGVyLCBcIjxkaXYgY2xhc3M9XFxcImd1aWRlLXNjZW5lQm91bmRzXFxcIj48L2Rpdj5cIik7XG4gICAgICA7XG4gICAgfSk7XG4gICAgc2NlbmUub24oQ29uc3QuU0NFTkVfUkVBRFksIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5zaXplKCk7XG5cbiAgICAgICAgaWYgKHNjZW5lLmNlbnRlciAhPSBmYWxzZSAmJiAhc2NlbmUuZml0KSB7XG4gICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIEZ1c2lvbkhlbHBlci5kZWJvdW5jZShfdGhpcy5jZW50ZXIuYmluZChfdGhpcyksIDUwKSk7XG5cbiAgICAgICAgICBfdGhpcy5jZW50ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2VuZS5maXQgIT0gZmFsc2UpIHtcbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgRnVzaW9uSGVscGVyLmRlYm91bmNlKF90aGlzLmZpdC5iaW5kKF90aGlzKSwgNTApKTtcblxuICAgICAgICAgIF90aGlzLmZpdCgpO1xuICAgICAgICB9XG4gICAgICB9LCAyMDApO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTaXplXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgICB0aGlzLmd1aWRlU2NlbmVCb3VuZHMuc3R5bGUud2lkdGggPSB0eXBlb2YgdGhpcy5zY2VuZS53aWR0aCA9PSAnc3RyaW5nJyA/IHRoaXMuc2NlbmUud2lkdGggOiBcIlwiLmNvbmNhdCh0aGlzLnNjZW5lLndpZHRoLCBcInB4XCIpO1xuICAgICAgdGhpcy5ndWlkZVNjZW5lQm91bmRzLnN0eWxlLmhlaWdodCA9IHR5cGVvZiB0aGlzLnNjZW5lLmhlaWdodCA9PSAnc3RyaW5nJyA/IHRoaXMuc2NlbmUuaGVpZ2h0IDogXCJcIi5jb25jYXQodGhpcy5zY2VuZS5oZWlnaHQsIFwicHhcIik7XG4gICAgICB0aGlzLnNjZW5lLmRhdGEubWF4V2lkdGggJiYgKHRoaXMuZ3VpZGVTY2VuZUJvdW5kcy5zdHlsZS5tYXhXaWR0aCA9IFwiXCIuY29uY2F0KHRoaXMuc2NlbmUubWF4V2lkdGgsIFwicHhcIikpO1xuICAgICAgdGhpcy5zY2VuZS5kYXRhLm1heEhlaWdodCAmJiAodGhpcy5ndWlkZVNjZW5lQm91bmRzLnN0eWxlLm1heEhlaWdodCA9IFwiXCIuY29uY2F0KHRoaXMuc2NlbmUubWF4SGVpZ2h0LCBcInB4XCIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2VudGVyIGd1aWRlU2NlbmVCb3VuZHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNlbnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjZW50ZXIoKSB7XG4gICAgICB0aGlzLmd1aWRlU2NlbmVCb3VuZHMuc3R5bGUubGVmdCA9ICc1MCUnO1xuICAgICAgdGhpcy5ndWlkZVNjZW5lQm91bmRzLnN0eWxlLnRvcCA9ICc1MCUnO1xuICAgICAgdGhpcy5ndWlkZVNjZW5lQm91bmRzLnN0eWxlLm1hcmdpbkxlZnQgPSBcIi1cIi5jb25jYXQodGhpcy5zY2VuZS53aWR0aCAqIHRoaXMuc2NlbmUuc2NhbGUgLyAyLCBcInB4XCIpO1xuICAgICAgdGhpcy5ndWlkZVNjZW5lQm91bmRzLnN0eWxlLm1hcmdpblRvcCA9IFwiLVwiLmNvbmNhdCh0aGlzLnNjZW5lLmhlaWdodCAqIHRoaXMuc2NlbmUuc2NhbGUgLyAyLCBcInB4XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBmaXQgZ3VpZGVTY2VuZUJvdW5kcyAocmVzcG9uc2l2ZSBzY2FsaW5nKVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpdCgpIHtcbiAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IHRoaXMuc2NlbmUucGxheWVyLnZpZXdwb3J0LmNsaWVudFdpZHRoO1xuICAgICAgdmFyIGF2YWlsYWJsZUhlaWdodCA9IHRoaXMuc2NlbmUucGxheWVyLnZpZXdwb3J0LmNsaWVudEhlaWdodDtcbiAgICAgIHRoaXMuc2NlbmUuc2NhbGUgPSBNYXRoLm1pbihhdmFpbGFibGVXaWR0aCAvIHRoaXMuc2NlbmUud2lkdGgsIGF2YWlsYWJsZUhlaWdodCAvIHRoaXMuc2NlbmUuaGVpZ2h0KTtcbiAgICAgIHRoaXMuc2NlbmUuc2NhbGUgPSB0aGlzLnNjZW5lLnNjYWxlID4gMSA/IDEgOiB0aGlzLnNjZW5lLnNjYWxlO1xuICAgICAgdGhpcy5ndWlkZVNjZW5lQm91bmRzLnN0eWxlLnRyYW5zZm9ybSA9IFwic2NhbGUoXCIuY29uY2F0KHRoaXMuc2NlbmUuc2NhbGUsIFwiKVwiKTtcbiAgICAgIHRoaXMuY2VudGVyKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufSgpO1xuXG5leHBvcnQgeyBfZGVmYXVsdCBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmltcG9ydCB7IEZ1c2lvbkhlbHBlciB9IGZyb20gJy4vRnVzaW9uSGVscGVyJztcbmltcG9ydCBGdXNpb25TY2VuZURlYnVnZ2VyIGZyb20gJy4vRnVzaW9uU2NlbmVEZWJ1Z2dlcic7XG5pbXBvcnQgTmFub0V2ZW50cyBmcm9tICcuLi8uLi9saWJzL25hbm9ldmVudHMnO1xuaW1wb3J0IENvbnN0IGZyb20gJy4uL0NvbnN0JztcbnZhciBMT0cgPSAnWyBGdXNpb25TY2VuZSBdJztcbnZhciBERUJVRyA9IHRydWU7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX05hbm9FdmVudHMpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfTmFub0V2ZW50cyk7XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHQocGxheWVyLCBkYXRhKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0KS5jYWxsKHRoaXMpKTtcbiAgICBfdGhpcy5wbGF5ZXIgPSBwbGF5ZXI7XG4gICAgX3RoaXMuZWxlbWVudDtcbiAgICBfdGhpcy5jb250ZW50O1xuICAgIF90aGlzLmRhdGEgPSBkYXRhO1xuICAgIF90aGlzLmlkID0gZGF0YS5pZDtcbiAgICBfdGhpcy53aWR0aCA9IGRhdGEud2lkdGg7XG4gICAgX3RoaXMuaGVpZ2h0ID0gZGF0YS5oZWlnaHQ7IC8vIERlYnVnZ2VyXG5cbiAgICBpZiAoX3RoaXMucGxheWVyLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgIF90aGlzW1wiZGVidWdnZXJcIl0gPSBuZXcgRnVzaW9uU2NlbmVEZWJ1Z2dlcihfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgfSAvLyBQbHVnaW5zXG5cblxuICAgIF90aGlzLmluaXRQbHVnaW5zKCk7XG5cbiAgICBfdGhpcy5lbWl0KENvbnN0LlNDRU5FX1BMVUdJTlNfUkVBRFkpOyAvLyBQcmVyZWFkeVxuXG5cbiAgICBfdGhpcy5vbihDb25zdC5TQ0VORV9QUkVfUkVBRFksIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnNpemUoKTtcblxuICAgICAgaWYgKF90aGlzLmRhdGEuY2VudGVyICE9IGZhbHNlICYmICFfdGhpcy5kYXRhLmZpdCkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgRnVzaW9uSGVscGVyLmRlYm91bmNlKF90aGlzLmNlbnRlci5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgNTApKTtcblxuICAgICAgICBfdGhpcy5jZW50ZXIoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLmRhdGEuZml0ICE9IGZhbHNlKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBGdXNpb25IZWxwZXIuZGVib3VuY2UoX3RoaXMuZml0LmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLCA1MCkpO1xuXG4gICAgICAgIF90aGlzLmZpdCgpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5lbWl0KENvbnN0LlNDRU5FX1JFQURZKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogU2l6ZVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwic2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaXplKCkge1xuICAgICAgdGhpcy5jb250ZW50LnN0eWxlLndpZHRoID0gdHlwZW9mIHRoaXMuZGF0YS53aWR0aCA9PSAnc3RyaW5nJyA/IHRoaXMuZGF0YS53aWR0aCA6IFwiXCIuY29uY2F0KHRoaXMuZGF0YS53aWR0aCwgXCJweFwiKTtcbiAgICAgIHRoaXMuY29udGVudC5zdHlsZS5oZWlnaHQgPSB0eXBlb2YgdGhpcy5kYXRhLmhlaWdodCA9PSAnc3RyaW5nJyA/IHRoaXMuZGF0YS5oZWlnaHQgOiBcIlwiLmNvbmNhdCh0aGlzLmRhdGEuaGVpZ2h0LCBcInB4XCIpO1xuICAgICAgdGhpcy5kYXRhLm1heFdpZHRoICYmICh0aGlzLmNvbnRlbnQuc3R5bGUubWF4V2lkdGggPSBcIlwiLmNvbmNhdCh0aGlzLmRhdGEubWF4V2lkdGgsIFwicHhcIikpO1xuICAgICAgdGhpcy5kYXRhLm1heEhlaWdodCAmJiAodGhpcy5jb250ZW50LnN0eWxlLm1heEhlaWdodCA9IFwiXCIuY29uY2F0KHRoaXMuZGF0YS5tYXhIZWlnaHQsIFwicHhcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDZW50ZXIgY29udGVudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2VudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNlbnRlcigpIHtcbiAgICAgIHRoaXMuY29udGVudC5zdHlsZS5sZWZ0ID0gJzUwJSc7XG4gICAgICB0aGlzLmNvbnRlbnQuc3R5bGUudG9wID0gJzUwJSc7XG4gICAgICB0aGlzLmNvbnRlbnQuc3R5bGUubWFyZ2luTGVmdCA9IFwiLVwiLmNvbmNhdCh0aGlzLmRhdGEud2lkdGggKiB0aGlzLnNjYWxlIC8gMiwgXCJweFwiKTtcbiAgICAgIHRoaXMuY29udGVudC5zdHlsZS5tYXJnaW5Ub3AgPSBcIi1cIi5jb25jYXQodGhpcy5kYXRhLmhlaWdodCAqIHRoaXMuc2NhbGUgLyAyLCBcInB4XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBmaXQgY29udGVudCAocmVzcG9uc2l2ZSBzY2FsaW5nKVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpdCgpIHtcbiAgICAgIHZhciBhdmFpbGFibGVXaWR0aCA9IHRoaXMucGxheWVyLnZpZXdwb3J0LmNsaWVudFdpZHRoO1xuICAgICAgdmFyIGF2YWlsYWJsZUhlaWdodCA9IHRoaXMucGxheWVyLnZpZXdwb3J0LmNsaWVudEhlaWdodDtcbiAgICAgIHRoaXMuc2NhbGUgPSBNYXRoLm1pbihhdmFpbGFibGVXaWR0aCAvIHRoaXMuZGF0YS53aWR0aCwgYXZhaWxhYmxlSGVpZ2h0IC8gdGhpcy5kYXRhLmhlaWdodCk7XG4gICAgICB0aGlzLnNjYWxlID0gdGhpcy5zY2FsZSA+IDEgPyAxIDogdGhpcy5zY2FsZTtcbiAgICAgIHRoaXMuY29udGVudC5zdHlsZS50cmFuc2Zvcm0gPSBcInNjYWxlKFwiLmNvbmNhdCh0aGlzLnNjYWxlLCBcIilcIik7XG4gICAgICB0aGlzLmNlbnRlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0IHBsdWdpbnNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImluaXRQbHVnaW5zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRQbHVnaW5zKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIC8vIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2luaXRQbHVnaW5zKCksIHBsdWdpbnM6JywgdGhpcy5kYXRhLnBsdWdpbnMpO1xuICAgICAgaWYgKCF0aGlzLmRhdGEucGx1Z2lucykgcmV0dXJuO1xuICAgICAgdGhpcy5kYXRhLnBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBtb2pvLnBsdWdpbnMpIHtcbiAgICAgICAgICBpZiAocGx1Z2luLmlkID09IG1vam8ucGx1Z2luc1trZXldLm1hbmlmZXN0KCkuaWQpIHtcbiAgICAgICAgICAgIG5ldyBtb2pvLnBsdWdpbnNba2V5XShfdGhpczIsIHBsdWdpbi5vcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oTmFub0V2ZW50cyk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuaW1wb3J0IEZ1c2lvblNjZW5lIGZyb20gJy4vRnVzaW9uU2NlbmUnO1xuaW1wb3J0IHsgRnVzaW9uSGVscGVyIH0gZnJvbSAnLi9GdXNpb25IZWxwZXInO1xuaW1wb3J0IENvbnN0IGZyb20gJy4uL0NvbnN0JztcbnZhciBMT0cgPSAnWyBGdXNpb25TY2VuZUlmcmFtZSBdJztcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRnVzaW9uU2NlbmUpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfRnVzaW9uU2NlbmUpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KHBsYXllciwgZGF0YSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuY2FsbCh0aGlzLCBwbGF5ZXIsIGRhdGEpKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJpZnJhbWVcIiwgdm9pZCAwKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwibG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkKCkge1xuICAgICAgY29uc29sZS5sb2coTE9HLCAnbG9hZCgpJyk7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgLy8gQ3JlYXRlIE1hcmt1cFxuICAgICAgdGhpcy5lbGVtZW50ID0gRnVzaW9uSGVscGVyLmFwcGVuZEh0bWwodGhpcy52aWV3cG9ydCwgXCI8ZGl2IGNsYXNzPVxcXCJmdXNpb24tLXNjZW5lIGZ1c2lvbi0tc2NlbmUtLWlmcmFtZSBzY2VuZS1cIi5jb25jYXQodGhpcy5pZCwgXCJcXFwiPjwvZGl2PlwiKSk7XG4gICAgICB0aGlzLmlmcmFtZSA9IEZ1c2lvbkhlbHBlci5hcHBlbmRIdG1sKHRoaXMuZWxlbWVudCwgXCI8aWZyYW1lIGNsYXNzPVxcXCJmdXNpb24tLWlmcmFtZVxcXCIgc3JjPVxcXCJcIi5jb25jYXQodGhpcy5kYXRhLnBhdGgsIFwiXFxcIiBmcmFtZWJvcmRlcj1cXFwiMFxcXCIgYWxsb3dUcmFuc3BhcmVuY3k9XFxcInRydWVcXFwiPjwvaWZyYW1lPlwiKSk7XG4gICAgICBGdXNpb25IZWxwZXIuYXBwZW5kSHRtbCh0aGlzLmVsZW1lbnQsIHRoaXMuZGF0YS5odG1sKTsgLy8gSWZyYW1lIFNpemVcblxuICAgICAgdGhpcy5pZnJhbWUuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICB0aGlzLmlmcmFtZS5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7IC8vIFByb3BhZ2F0ZSBwcmVyZWFkeVxuXG4gICAgICB0aGlzLmVtaXQoQ29uc3QuU0NFTkVfUFJFX1JFQURZKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ1c2lvblNjZW5lKTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5pbXBvcnQgRnVzaW9uU2NlbmUgZnJvbSAnLi9GdXNpb25TY2VuZSc7XG5pbXBvcnQgeyBGdXNpb25IZWxwZXIgfSBmcm9tICcuL0Z1c2lvbkhlbHBlcic7XG5pbXBvcnQgQ29uc3QgZnJvbSAnLi4vQ29uc3QnO1xudmFyIExPRyA9ICdbIEZ1c2lvblNjZW5lRGVmYXVsdCBdJztcbnZhciBERUJVRyA9IGZhbHNlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9GdXNpb25TY2VuZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9GdXNpb25TY2VuZSk7XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHQocGxheWVyLCBkYXRhKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmNhbGwodGhpcywgcGxheWVyLCBkYXRhKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcImxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZCgpIHtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2xvYWQoKScpO1xuICAgICAgdGhpcy5sb2FkTWFuaWZlc3QodGhpcy5yZW5kZXIuYmluZCh0aGlzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvYWRNYW5pZmVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkTWFuaWZlc3QocmVzb2x2ZSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnbG9hZE1hbmlmZXN0KCknKTtcbiAgICAgIHZhciBxdWV1ZSA9IG5ldyBjcmVhdGVqcy5Mb2FkUXVldWUoZmFsc2UpO1xuICAgICAgcXVldWUubG9hZE1hbmlmZXN0KHRoaXMuZGF0YS5wYXRoICsgJy9tYW5pZmVzdC5qc29uJywgdHJ1ZSwgJycpO1xuICAgICAgcXVldWUub24oXCJmaWxlbG9hZFwiLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2ZpbGVsb2FkKCksICcsIGV2dC5pdGVtLmlkLCBldnQpO1xuICAgICAgICBfdGhpcy5kYXRhW2V2dC5pdGVtLmlkXSA9IGV2dC5yZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHF1ZXVlLm9uKFwiY29tcGxldGVcIiwgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdsb2FkTWFuaWZlc3QoKSwgbWFuaWZlc3QgY29tcGxldGUuLi4nLCBldnQpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICAgIHF1ZXVlLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIGluIGxvYWRNYW5pZmVzdCgpIGR1cmluZyBwcmVsb2FkaW5nLiAnICsgZXZ0Lm1lc3NhZ2UpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAvLyBDcmVhdGUgTWFya3VwXG4gICAgICB0aGlzLmVsZW1lbnQgPSBGdXNpb25IZWxwZXIuYXBwZW5kSHRtbCh0aGlzLnBsYXllci52aWV3cG9ydCwgXCI8ZGl2IGNsYXNzPVxcXCJmdXNpb24tLXNjZW5lIGZ1c2lvbi0tc2NlbmUtLWRlZmF1bHQgc2NlbmUtXCIuY29uY2F0KHRoaXMuaWQsIFwiXFxcIj48L2Rpdj5cIikpO1xuICAgICAgdGhpcy5jb250ZW50ID0gRnVzaW9uSGVscGVyLmFwcGVuZEh0bWwodGhpcy5lbGVtZW50LCBcIjxkaXYgY2xhc3M9XFxcImZ1c2lvbi0tc2NlbmUtLWNvbnRlbnRcXFwiPjwvZGl2PlwiKTtcbiAgICAgIEZ1c2lvbkhlbHBlci5hcHBlbmRIdG1sKHRoaXMuY29udGVudCwgdGhpcy5kYXRhLmh0bWwpOyAvLyBFeGVjdXRlIHNjZW5lIHNjcmlwdFxuXG4gICAgICB2YXIgc2NyaXB0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpOyAvLyBXcmFwIHNjcmlwdCB0byBpbmplY3QgYWRkaXRpb25hbCBwbGF5ZXIvc2NlbmUgZGF0YVxuXG4gICAgICB2YXIgc2NyaXB0ID0gXCJcXG4gICAgICAoZnVuY3Rpb24oc2NlbmUpIHtcXG4gICAgICAgIHZhciBwbGF5ZXJJZCA9ICdcIi5jb25jYXQodGhpcy5wbGF5ZXIuaWQsIFwiJztcXG4gICAgICAgIHZhciBzY2VuZUlkID0gJ1wiKS5jb25jYXQodGhpcy5pZCwgXCInO1xcbiAgICAgICAgdmFyIHBsYXllciA9IHdpbmRvdy5mdXNpb25QbGF5ZXJbcGxheWVySWRdO1xcbiAgICAgICAgdmFyIHNjZW5lID0gcGxheWVyLmdldFNjZW5lKHNjZW5lSWQpO1xcblxcbiAgICAgICAgXCIpLmNvbmNhdCh0aGlzLmRhdGEuc2NyaXB0LCBcIlxcbiAgICAgICAgXCIpLmNvbmNhdCh0aGlzLmRhdGEuc2NyaXB0MiA/IHRoaXMuZGF0YS5zY3JpcHQyIDogJycsIFwiXFxuICAgICAgICBcIikuY29uY2F0KHRoaXMuZGF0YS5zY3JpcHQzID8gdGhpcy5kYXRhLnNjcmlwdDMgOiAnJywgXCJcXG4gICAgICAgIFwiKS5jb25jYXQodGhpcy5kYXRhLnNjcmlwdDQgPyB0aGlzLmRhdGEuc2NyaXB0NCA6ICcnLCBcIlxcbiAgICAgIH0pKCk7XFxuICAgIFwiKTtcbiAgICAgIHNjcmlwdEVsZW1lbnQuaW5uZXJIVE1MID0gc2NyaXB0O1xuICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdEVsZW1lbnQpOyAvLyBQcm9wYWdhdGUgcHJlcmVhZHlcblxuICAgICAgdGhpcy5lbWl0KENvbnN0LlNDRU5FX1BSRV9SRUFEWSk7IC8vIFNjYW4gZm9yIG1vam8gZnhcblxuICAgICAgbW9qby5meC5GeFNjYW5uZXIuc2Nhbih0aGlzLmNvbnRlbnQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnVzaW9uU2NlbmUpO1xuXG5leHBvcnQgeyBfZGVmYXVsdCBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5pbXBvcnQgeyBGdXNpb25IZWxwZXIgfSBmcm9tICcuL0Z1c2lvbkhlbHBlcic7XG5pbXBvcnQgRnVzaW9uU2NlbmVJZnJhbWUgZnJvbSAnLi9GdXNpb25TY2VuZUlmcmFtZSc7XG5pbXBvcnQgRnVzaW9uU2NlbmVEZWZhdWx0IGZyb20gJy4vRnVzaW9uU2NlbmVEZWZhdWx0JztcbnZhciBMT0cgPSAnWyBGdXNpb25QbGF5ZXIgXSc7XG4vKipcbiAqIE1vam9GdXNpb25QbGF5ZXIgQ2xhc3NcbiAqL1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBfZGVmYXVsdChvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWZhdWx0c1wiLCB7XG4gICAgICBvdmVyZmxvd1g6ICdoaWRkZW4nLFxuICAgICAgb3ZlcmZsb3dZOiAnaGlkZGVuJ1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid3JhcHBlclwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidmlld3BvcnRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNjZW5lc1wiLCBbXSk7XG5cbiAgICB3aW5kb3cuZnVzaW9uUGxheWVyID0gd2luZG93LmZ1c2lvblBsYXllciA/IHdpbmRvdy5mdXNpb25QbGF5ZXIgOiB7fTtcbiAgICB3aW5kb3cuZnVzaW9uUGxheWVyW29wdGlvbnMuaWRdID0gdGhpcztcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHRoaXMuZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgIHRoaXMuaWQgPSBvcHRpb25zLmlkO1xuICAgIHRoaXMud3JhcHBlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdGlvbnMuaWQpO1xuICAgIHRoaXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKCdmdXNpb24tLXBsYXllcicpO1xuICAgIHRoaXMuY3JlYXRlTWFya3VwKCk7XG4gICAgdGhpcy52aWV3cG9ydCA9IHRoaXMud3JhcHBlci5xdWVyeVNlbGVjdG9yKCcuZnVzaW9uLS12aWV3cG9ydCcpOyAvLyBWaWV3cG9ydCBpcyBub3cgYWx3YXlzIDEwMCUgb2YgcGxheWVyXG4gICAgLy8gdGhpcy52aWV3cG9ydC5zdHlsZS53aWR0aCA9ICh0eXBlb2YgdGhpcy5vcHRpb25zLndpZHRoID09ICdzdHJpbmcnKSA/IHRoaXMub3B0aW9ucy53aWR0aCA6IGAke3RoaXMub3B0aW9ucy53aWR0aH1weGA7XG4gICAgLy8gdGhpcy52aWV3cG9ydC5zdHlsZS5oZWlnaHQgPSAodHlwZW9mIHRoaXMub3B0aW9ucy5oZWlnaHQgPT0gJ3N0cmluZycpID8gdGhpcy5vcHRpb25zLmhlaWdodCA6IGAke3RoaXMub3B0aW9ucy5oZWlnaHR9cHhgO1xuXG4gICAgdGhpcy52aWV3cG9ydC5zdHlsZS5vdmVyZmxvdyA9IFwiYXV0b1wiOyAvLyBDcmVhdGUgc2NlbmUgb2JqZWN0c1xuXG4gICAgdGhpcy5vcHRpb25zLnNjZW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChzY2VuZSkge1xuICAgICAgc2NlbmUud2lkdGggPSBzY2VuZS53aWR0aCB8fCBfdGhpcy5vcHRpb25zLndpZHRoO1xuICAgICAgc2NlbmUuaGVpZ2h0ID0gc2NlbmUuaGVpZ2h0IHx8IF90aGlzLm9wdGlvbnMuaGVpZ2h0O1xuXG4gICAgICBzd2l0Y2ggKHNjZW5lLmlmcmFtZSkge1xuICAgICAgICBjYXNlIHRydWU6XG4gICAgICAgICAgX3RoaXMuc2NlbmVzLnB1c2gobmV3IEZ1c2lvblNjZW5lSWZyYW1lKF90aGlzLCBzY2VuZSkpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBfdGhpcy5zY2VuZXMucHVzaChuZXcgRnVzaW9uU2NlbmVEZWZhdWx0KF90aGlzLCBzY2VuZSkpO1xuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7IC8vIHRoaXMubG9hZFNjZW5lKCdzY2VuZTEnKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiY3JlYXRlTWFya3VwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZU1hcmt1cCgpIHtcbiAgICAgIEZ1c2lvbkhlbHBlci5hcHBlbmRIdG1sKHRoaXMud3JhcHBlciwgJzxkaXYgY2xhc3M9XCJmdXNpb24tLXZpZXdwb3J0XCI+PC9kaXY+Jyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNjZW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNjZW5lKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY2VuZXMuZmluZChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5pZCA9PT0gaWQ7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZFNjZW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWRTY2VuZShpZCkge1xuICAgICAgdmFyIHNjZW5lID0gdGhpcy5nZXRTY2VuZShpZCk7XG5cbiAgICAgIGlmICghc2NlbmUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihMT0csICdTY2VuZSBub3QgZm91bmQ6JywgaWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNjZW5lLmxvYWQoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KCk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogTWFnbmV0IF0nO1xudmFyIERFQlVHID0gZmFsc2U7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Z4QmFzZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9GeEJhc2UpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImluaXRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgZ3NhcC50byh0aGlzLmVsZW1lbnQsIHtcbiAgICAgICAgc2NhbGU6IHRoaXMub3B0aW9ucy5zY2FsZSxcbiAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiAnNTAlIDUwJScsXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLm9wdGlvbnMuZHVyYXRpb24gLyAxMDAwLFxuICAgICAgICBlYXNlOiAncG93ZXI0Lm91dCg5KSdcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge1xuICAgICAgZ3NhcC5pc1R3ZWVuaW5nKHRoaXMuZWxlbWVudCkgJiYgZ3NhcC5raWxsVHdlZW5zT2YodGhpcy5lbGVtZW50LCAnc2NhbGUnKTtcbiAgICAgIGdzYXAudG8odGhpcy5lbGVtZW50LCB7XG4gICAgICAgIHNjYWxlOiAxLFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5vcHRpb25zLmR1cmF0aW9uIC8gMTAwMCxcbiAgICAgICAgZWFzZTogdGhpcy5vcHRpb25zLmVhc2VPdXRcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICdNYWduZXQnLFxuICBvcHRpb25zOiB7XG4gICAgdHJpZ2dlcjogJ2hvdmVyJyxcbiAgICBkdXJhdGlvbjogNTAwLFxuICAgIHNjYWxlOiAxLjIsXG4gICAgZWFzZU91dDogJ2JhY2sub3V0KDMpJ1xuICB9XG59KTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vLyBFeHBlcmltZW50YWwgRWZmZWN0XG5pbXBvcnQgRnhCYXNlIGZyb20gJy4uLy4uL0Z4QmFzZSc7XG52YXIgTE9HID0gJ1sgRlggOiBBbmltYXRlTWFnbmV0IChBbmltZSkgXSc7XG52YXIgREVCVUcgPSB0cnVlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9GeEJhc2UpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfRnhCYXNlKTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImFuXCIsIHZvaWQgMCk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImluaXRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb24odGhpcy5hbik7XG4gICAgICB0aGlzLmFuID0gYW5pbWUoe1xuICAgICAgICB0YXJnZXRzOiB0aGlzLmVsZW1lbnQsXG4gICAgICAgIHNjYWxlOiB0aGlzLm9wdGlvbnMuc2NhbGUsXG4gICAgICAgIGR1cmF0aW9uOiA2MDAsXG4gICAgICAgIGVhc2luZzogJ2Vhc2VPdXRFeHBvJ1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQoKSB7XG4gICAgICAvLyBnc2FwLmlzVHdlZW5pbmcodGhpcy5lbGVtZW50KSAmJiBnc2FwLmtpbGxUd2VlbnNPZih0aGlzLmVsZW1lbnQpO1xuICAgICAgLy8gZ3NhcC50byh0aGlzLmVsZW1lbnQsIHtzY2FsZTogMSwgZHVyYXRpb246IDAuNCwgZWFzZTogdGhpcy5vcHRpb25zLmVhc2VPdXR9KTtcbiAgICAgIC8vIHRoaXMuYW4uZW5kLnJlc3RhcnQoKTtcbiAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uKHRoaXMuYW4pO1xuICAgICAgdGhpcy5hbiA9IGFuaW1lKHtcbiAgICAgICAgdGFyZ2V0czogdGhpcy5lbGVtZW50LFxuICAgICAgICBzY2FsZTogMSxcbiAgICAgICAgZHVyYXRpb246IDQwMCxcbiAgICAgICAgZWFzaW5nOiAnZWFzZU91dEJhY2snXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuY2VsQW5pbWF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbEFuaW1hdGlvbihhbmltYXRpb24pIHtcbiAgICAgIGFuaW1hdGlvbiAmJiBhbmltYXRpb24ucGF1c2UoKTsgLy8gbGV0IGFjdGl2ZUluc3RhbmNlcyA9IGFuaW1lLnJ1bm5pbmc7XG4gICAgICAvLyBsZXQgaW5kZXggPSBhY3RpdmVJbnN0YW5jZXMuaW5kZXhPZihhbmltYXRpb24pO1xuICAgICAgLy8gYWN0aXZlSW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufShGeEJhc2UpO1xuXG5fZGVmaW5lUHJvcGVydHkoX2RlZmF1bHQsIFwibWFuaWZlc3RcIiwge1xuICBpZDogJ01hZ25ldCcsXG4gIG9wdGlvbnM6IHtcbiAgICBzY2FsZTogMS4yLFxuICAgIGVhc2VPdXQ6ICdiYWNrLm91dCgzKSdcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogVHlwZUFuaW1hdGlvbiBdJztcbnZhciBERUJVRyA9IHRydWU7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Z4QmFzZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9GeEJhc2UpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImluaXRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJzdGFydFwiLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2luaXQoKScsIHRoaXMub3B0aW9ucyk7IC8vIFByZXBhcmUgZWxlbWVudHNcbiAgICAgIC8vIFdyYXAgZXZlcnkgbGV0dGVyIGluIGEgc3BhblxuICAgICAgLy8gdGhpcy5lbGVtZW50LmlubmVySFRNTCA9IHRoaXMuZWxlbWVudC50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFMvZywgXCI8c3BhbiBjbGFzcz0nbGV0dGVyJz4kJjwvc3Bhbj5cIik7XG5cbiAgICAgIHRoaXMuZWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLmVsZW1lbnQudGV4dENvbnRlbnQucmVwbGFjZSgvW1xcU1xcV10vZywgXCI8c3BhbiBjbGFzcz0nbGV0dGVyJz4kJjwvc3Bhbj5cIikucmVwbGFjZSgvPiA8L2csIFwiPiZuYnNwOzxcIik7XG4gICAgICBnc2FwLnNldCh0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmxldHRlcicpLCB7XG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdzdGFydCgpJyk7XG4gICAgICBnc2FwLmZyb21Ubyh0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmxldHRlcicpLCB7XG4gICAgICAgIHNjYWxlOiAyXG4gICAgICB9LCB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHNjYWxlOiAxLFxuICAgICAgICBkZWxheTogdGhpcy5vcHRpb25zLmRlbGF5LFxuICAgICAgICBkdXJhdGlvbjogMC4yLFxuICAgICAgICBzdGFnZ2VyOiAxIC8gKHRoaXMub3B0aW9ucy5zcGVlZCAvIDIpLFxuICAgICAgICBlYXNlOiAnYmFjay5vdXQoMyknXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ4QmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAndHlwZScsXG4gIG9wdGlvbnM6IHtcbiAgICB0cmlnZ2VyOiAnYXV0bycsXG4gICAgc3BlZWQ6IDEwMCxcbiAgICBkZWxheTogLjVcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogUGFydGljbGVzIF0nO1xudmFyIERFQlVHID0gdHJ1ZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRnhCYXNlKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX0Z4QmFzZSk7XG5cbiAgLy8gRWZmZWN0IGNlbnRlclxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImNlbnRlclwiLCB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfSk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImluaXRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdpbml0KCknLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgbW9qby5GdXNpb25IZWxwZXIuYXBwZW5kSHRtbChkb2N1bWVudC5ib2R5LCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB4bWxuczp4bGluaz1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1xcXCIgd2lkdGg9XFxcIjgyXFxcIiBoZWlnaHQ9XFxcIjEyOVxcXCIgdmlld0JveD1cXFwiMCAwIDgyIDEyOVxcXCIgc3R5bGU9XFxcImRpc3BsYXk6IG5vbmVcXFwiPlxcbiAgICAgIDxjaXJjbGUgaWQ9XFxcInRwbENpcmNsZVxcXCIgY3g9XFxcIjkuNVxcXCIgY3k9XFxcIjkuNVxcXCIgcj1cXFwiOS41XFxcIiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiNmZmZcXFwiIHN0cm9rZS13aWR0aD1cXFwiM1xcXCIvPlxcbiAgICAgIDxwYXRoIGlkPVxcXCJ0cGxUcmlhbmdsZVxcXCIgZD1cXFwiTTkuNSwwLDE5LDE3SDBaXFxcIiBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiNmZmZcXFwiIHN0cm9rZS13aWR0aD1cXFwiM1xcXCIvPlxcbiAgICAgIDxyZWN0IGlkPVxcXCJ0cGxSZWN0XFxcIiB3aWR0aD1cXFwiMTlcXFwiIGhlaWdodD1cXFwiMTlcXFwiIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiI2ZmZlxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIzXFxcIi8+XFxuICAgIDwvc3ZnPlwiKTsgLy8gR2F0aGVyIHRlbXBsYXRlc1xuXG4gICAgICB0aGlzLnRlbXBsYXRlcyA9IFt7XG4gICAgICAgIG5vZGU6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cGxDaXJjbGUnKVxuICAgICAgfSwge1xuICAgICAgICBub2RlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHBsVHJpYW5nbGUnKVxuICAgICAgfSwge1xuICAgICAgICBub2RlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHBsUmVjdCcpXG4gICAgICB9XTsgLy8gQ2FjaGUgd2lkdGgvaGVpZ2h0XG5cbiAgICAgIHRoaXMudGVtcGxhdGVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIHJlY3QgPSBpdGVtLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGl0ZW0ud2lkdGggPSByZWN0LndpZHRoO1xuICAgICAgICBpdGVtLmhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICd1cGRhdGUoKScpOyAvLyBsZXQgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudCk7XG4gICAgICAvLyB0aGlzLmNlbnRlciA9IHtcbiAgICAgIC8vICAgbGVmdDogcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5sZWZ0KSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGUud2lkdGgpLzIsXG4gICAgICAvLyAgIHRvcDogcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS50b3ApICsgcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5oZWlnaHQpLzIgXG4gICAgICAvLyB9O1xuICAgICAgLy8gREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAndXBkYXRlKCkgY2VudGVyOicsIHRoaXMuY2VudGVyKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0TG9jYWxCb3VuZGluZ0NsaWVudFJlY3QoZWwpIHtcbiAgICAgICAgdmFyIGEgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIGIgPSBlbC5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxlZnQ6IGEubGVmdCAtIGIubGVmdCxcbiAgICAgICAgICB0b3A6IGEudG9wIC0gYi50b3AsXG4gICAgICAgICAgd2lkdGg6IGEud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBhLmhlaWdodFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjdCA9IGdldExvY2FsQm91bmRpbmdDbGllbnRSZWN0KHRoaXMuZWxlbWVudCk7XG4gICAgICB0aGlzLmNlbnRlciA9IHtcbiAgICAgICAgbGVmdDogTWF0aC5yb3VuZChyZWN0LmxlZnQgKyByZWN0LndpZHRoIC8gMiksXG4gICAgICAgIHRvcDogTWF0aC5yb3VuZChyZWN0LnRvcCArIHJlY3QuaGVpZ2h0IC8gMilcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnc3RhcnQoKScpO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIHZhciBzdmcgPSBtb2pvLkZ1c2lvbkhlbHBlci5hcHBlbmRIdG1sKHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50LCBcIjxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB4bWxuczp4bGluaz1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1xcXCIgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMVxcXCIgdmlld0JveD1cXFwiMCAwIDEgMVxcXCIgc3R5bGU9XFxcInBvaW50ZXItZXZlbnRzOiBub25lOyBwb3NpdGlvbjogYWJzb2x1dGU7IG92ZXJmbG93OiB2aXNpYmxlO1xcXCI+PC9zdmc+XCIpO1xuICAgICAgc3ZnLnN0eWxlLmxlZnQgPSB0aGlzLmNlbnRlci5sZWZ0ICsgJ3B4JztcbiAgICAgIHN2Zy5zdHlsZS50b3AgPSB0aGlzLmNlbnRlci50b3AgKyAncHgnOyAvLyBHZW5lcmF0ZVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICB2YXIgdHBsID0gdGhpcy50ZW1wbGF0ZXNbTWF0aC5jZWlsKE1hdGgucmFuZG9tKCkgKiB0aGlzLnRlbXBsYXRlcy5sZW5ndGgpIC0gMV07XG4gICAgICAgIHZhciBub2RlID0gdHBsLm5vZGUuY2xvbmVOb2RlKCk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdpZCcsICdyYW5kb20tJyArIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMDAwKSk7XG4gICAgICAgIG5vZGUuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIG5vZGUuc3R5bGUub3BhY2l0eSA9IDA7IC8vIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnKyhvcmlnaW5YLXRwbC53aWR0aC8yKSsncHgsICcrKG9yaWdpblktdHBsLmhlaWdodC8yKSsncHgpJztcblxuICAgICAgICBub2RlLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLTEwcHgsIC0xMHB4KSc7XG4gICAgICAgIHN2Zy5hcHBlbmRDaGlsZChub2RlKTsgLy9nc2FwLnRvKG5vZGUsIHtkdXJhdGlvbjogMC4yKmksIG9wYWNpdHk6IDEsIHk6ICctPTgwJywgcm90YXRpb246IDM2MCwgdHJhbnNmb3JtT3JpZ2luOiBcIjUwJSA1MCVcIn0pO1xuXG4gICAgICAgIHZhciB0bCA9IGdzYXAudGltZWxpbmUoe1xuICAgICAgICAgIGRlbGF5OiAwLjA1ICogaVxuICAgICAgICB9KTsgLy8gdGwudGltZVNjYWxlKDAuMSk7XG5cbiAgICAgICAgdmFyIHggPSBpICUgMiA/IC00MCAqIChNYXRoLnJhbmRvbSgpICogMiAqIHRoaXMub3B0aW9ucy5wb3dlcikgOiA0MCAqIChNYXRoLnJhbmRvbSgpICogMiAqIHRoaXMub3B0aW9ucy5wb3dlcik7XG4gICAgICAgIHZhciB5ID0gLTMwICogKGkgLyAyICsgMSkgKiB0aGlzLm9wdGlvbnMucG93ZXI7XG4gICAgICAgIHRsLnRvKG5vZGUsIHtcbiAgICAgICAgICBkdXJhdGlvbjogMS40LFxuICAgICAgICAgIGVhc2U6IFwicG93ZXIzLm91dFwiLFxuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICByb3RhdGlvbjogMTMwLFxuICAgICAgICAgIHNjYWxlOiB0aGlzLm9wdGlvbnMuc2NhbGUsXG4gICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBcIjUwJSA1MCVcIlxuICAgICAgICB9LCAwKTtcbiAgICAgICAgdGwudG8obm9kZSwge1xuICAgICAgICAgIGR1cmF0aW9uOiAwLjIsXG4gICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICB9LCAwKTtcbiAgICAgICAgdGwudG8obm9kZSwge1xuICAgICAgICAgIGR1cmF0aW9uOiAwLjMsXG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCBcIi09XCIuY29uY2F0KDAuMyAqIHRoaXMub3B0aW9ucy5kZWNheSkpO1xuICAgICAgICB0bC5ldmVudENhbGxiYWNrKFwib25Db21wbGV0ZVwiLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG5cbiAgICAgICAgICBpZiAocGFyZW50Tm9kZS5jaGlsZHJlbi5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHBhcmVudE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgW25vZGVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZCgpIHt9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ4QmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAnUGFydGljbGVzJyxcbiAgb3B0aW9uczoge1xuICAgIHRyaWdnZXI6ICdjbGljaycsXG4gICAgc2NhbGU6IDIsXG4gICAgcG93ZXI6IDIsXG4gICAgZGVjYXk6IDNcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogU3ByaXRlc2hlZXQgXSc7XG52YXIgREVCVUcgPSBmYWxzZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRnhCYXNlKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX0Z4QmFzZSk7XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ0bFwiLCB2b2lkIDApO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnb3B0aW9uczonLCB0aGlzLm9wdGlvbnMpOyAvLyBQcmVwYXJlXG4gICAgICAvLyNCVUc6IGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIGlzIGFsd2F5cyBub24tc2NhbGVkIGluIGdsb2JhbCBzcGFjZVxuICAgICAgLy8gbGV0IGJvdW5kcyA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIC8vICEodGhpcy5vcHRpb25zLndpZHRoKSAmJiAodGhpcy5vcHRpb25zLndpZHRoID0gYm91bmRzLndpZHRoKTsgXG4gICAgICAvLyAhKHRoaXMub3B0aW9ucy5oZWlnaHQpICYmICh0aGlzLm9wdGlvbnMuaGVpZ2h0ID0gYm91bmRzLmhlaWdodCk7XG4gICAgICAvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgc2VlbXMgdG8gd29yayBiZXR0ZXIgd2l0aCBzY2FsaW5nXG5cbiAgICAgICF0aGlzLm9wdGlvbnMud2lkdGggJiYgKHRoaXMub3B0aW9ucy53aWR0aCA9IHRoaXMuZWxlbWVudC5vZmZzZXRXaWR0aCk7XG4gICAgICAhdGhpcy5vcHRpb25zLmhlaWdodCAmJiAodGhpcy5vcHRpb25zLmhlaWdodCA9IHRoaXMuZWxlbWVudC5vZmZzZXRIZWlnaHQpOyAvLyAvLyBTZXQgYmFja2dyb3VuZCBpbWFnZVxuXG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gXCJ1cmwoXCIuY29uY2F0KHRoaXMub3B0aW9ucy5zcmMsIFwiKVwiKTtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSBcIjAgMFwiO1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmJhY2tncm91bmRTaXplID0gXCJcIi5jb25jYXQodGhpcy5vcHRpb25zLndpZHRoICogdGhpcy5vcHRpb25zLnN0ZXBzLCBcInB4XCIpO1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmJhY2tncm91bmRSZXBlYXQgPSBcIm5vLXJlcGVhdFwiO1xuICAgICAgdGhpcy50bCA9IGdzYXAudGltZWxpbmUoe1xuICAgICAgICBwYXVzZWQ6IHRydWUsXG4gICAgICAgIHJlcGVhdDogdGhpcy5vcHRpb25zLmxvb3AgPyAtMSA6IDBcbiAgICAgIH0pO1xuICAgICAgdGhpcy50bC5hZGQoZ3NhcC50byh0aGlzLmVsZW1lbnQsIHtcbiAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy5kdXJhdGlvbiAvIDEwMDAsXG4gICAgICAgIGJhY2tncm91bmRQb3NpdGlvblg6IFwiLVwiLmNvbmNhdCh0aGlzLm9wdGlvbnMud2lkdGggKiAodGhpcy5vcHRpb25zLnN0ZXBzIC0gMSksIFwicHhcIiksXG4gICAgICAgIGVhc2U6IFwic3RlcHMoXCIuY29uY2F0KHRoaXMub3B0aW9ucy5zdGVwcyAtIDEsIFwiKVwiKVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHRoaXMudGwucGxheSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge1xuICAgICAgdGhpcy50bC5yZXZlcnNlKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufShGeEJhc2UpO1xuXG5fZGVmaW5lUHJvcGVydHkoX2RlZmF1bHQsIFwibWFuaWZlc3RcIiwge1xuICBpZDogJ1Nwcml0ZXNoZWV0JyxcbiAgb3B0aW9uczoge1xuICAgIHRyaWdnZXI6ICdjbGljaycsXG4gICAgbG9vcDogZmFsc2UsXG4gICAgZHVyYXRpb246IDUwMCxcbiAgICB3aWR0aDogdW5kZWZpbmVkLFxuICAgIGhlaWdodDogdW5kZWZpbmVkLFxuICAgIHN0ZXBzOiB1bmRlZmluZWRcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogSnVtcCBdJztcbnZhciBERUJVRyA9IGZhbHNlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9GeEJhc2UpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfRnhCYXNlKTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImluaXRpYWxcIiwgdm9pZCAwKTtcblxuICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwiaW5pdFwiLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcInN0YXJ0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnaW5pdCgpJywgdGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMuaW5pdGlhbCA9IHtcbiAgICAgICAgeTogZ3NhcC5nZXRQcm9wZXJ0eSh0aGlzLmVsZW1lbnQsICd5JylcbiAgICAgIH07XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICd0aGlzLmluaXRpYWwnLCB0aGlzLmluaXRpYWwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ3N0YXJ0KCknKTtcbiAgICAgIGdzYXAudG8odGhpcy5lbGVtZW50LCB7XG4gICAgICAgIHk6IHRoaXMuaW5pdGlhbC55IC0gMjAsXG4gICAgICAgIGR1cmF0aW9uOiAwLjQsXG4gICAgICAgIGVhc2U6ICdwb3dlci5vdXQoNCknXG4gICAgICB9KTtcbiAgICAgIGdzYXAudG8odGhpcy5lbGVtZW50LCB7XG4gICAgICAgIHk6IHRoaXMuaW5pdGlhbC55LFxuICAgICAgICBkdXJhdGlvbjogMC41LFxuICAgICAgICBkZWxheTogMC41LFxuICAgICAgICBlYXNlOiAnYm91bmNlLm91dCgyMCknXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ4QmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAnanVtcCcsXG4gIG9wdGlvbnM6IHt9XG59KTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vLyBFeHBlcmltZW50YWwgRWZmZWN0XG5pbXBvcnQgRnhCYXNlIGZyb20gJy4uL0Z4QmFzZSc7XG52YXIgTE9HID0gJ1sgRlggOiBIYW5kQ3Vyc29yIF0nO1xudmFyIERFQlVHID0gdHJ1ZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRnhCYXNlKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX0Z4QmFzZSk7XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblxuICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwiaW5pdFwiLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2luaXQoKScsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHt9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgZWxlbWVudHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdlbmVyYXRlRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVFbGVtZW50cygpIHt9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ4QmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAnaGFuZC1jdXJzb3InLFxuICBvcHRpb25zOiB7XG4gICAgdHJpZ2dlcjogJ2F1dG8nXG4gIH1cbn0pO1xuXG5leHBvcnQgeyBfZGVmYXVsdCBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8vIEV4cGVyaW1lbnRhbCBFZmZlY3RcbmltcG9ydCBGeEJhc2UgZnJvbSAnLi4vRnhCYXNlJztcbnZhciBMT0cgPSAnWyBGWCA6IEdsaXRjaCBdJztcbnZhciBERUJVRyA9IHRydWU7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Z4QmFzZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9GeEJhc2UpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgX3RoaXMub3JpZ2luYWw7XG4gICAgX3RoaXMuY29tcHV0ZWRTdHlsZTtcblxuICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwiaW5pdFwiLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2luaXQoKScsIHRoaXMub3B0aW9ucyk7IC8vIFByZXBhcmUgZWxlbWVudHNcblxuICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSB0aGlzLmNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsZW1lbnQpO1xuICAgICAgdGhpcy5vcmlnaW5hbCA9IHRoaXMuZWxlbWVudDsgLy8gV3JhcCBldmVyeXRoaW5nIGluIGRpdlxuXG4gICAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IGNvbXB1dGVkU3R5bGUucG9zaXRpb247XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSBjb21wdXRlZFN0eWxlLndpZHRoO1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IGNvbXB1dGVkU3R5bGUuaGVpZ2h0O1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnRvcCA9IGNvbXB1dGVkU3R5bGUudG9wO1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmxlZnQgPSBjb21wdXRlZFN0eWxlLmxlZnQ7IC8vIHRoaXMuZWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuXG4gICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdtb2pvLWZ4LWdsaXRjaCcsIHRoaXMub3JpZ2luYWwuZ2V0QXR0cmlidXRlKCdtb2pvLWZ4LWdsaXRjaCcpKTtcbiAgICAgIHRoaXMub3JpZ2luYWwucmVtb3ZlQXR0cmlidXRlKCdtb2pvLWZ4LWdsaXRjaCcpO1xuICAgICAgdGhpcy5vcmlnaW5hbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmVsZW1lbnQsIHRoaXMub3JpZ2luYWwpO1xuICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKHRoaXMub3JpZ2luYWwpOyAvLyBXcmFwIG9yaWdpbmFsIGluIGRpdiAoZm9yIG1hc2tpbmcgZXRjLilcblxuICAgICAgdmFyIGxheWVyV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5vcmlnaW5hbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShsYXllcldyYXBwZXIsIHRoaXMub3JpZ2luYWwpO1xuICAgICAgbGF5ZXJXcmFwcGVyLmFwcGVuZENoaWxkKHRoaXMub3JpZ2luYWwpO1xuICAgICAgdGhpcy5vcmlnaW5hbCA9IGxheWVyV3JhcHBlcjsgLy8gZ3NhcC5zZXQodGhpcy5vcmlnaW5hbCwge29wYWNpdHk6IDB9KTtcbiAgICAgIC8vIEdlbmVyYXRlIEVsZW1lbnRzXG5cbiAgICAgIHRoaXMuZ2VuZXJhdGVFbGVtZW50cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdzdGFydCgpJyk7XG4gICAgICB2YXIgZ2xpdGNoZWQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmdsaXRjaGVkJyk7XG4gICAgICBnc2FwLnNldChnbGl0Y2hlZCwge1xuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9KTtcbiAgICAgIHZhciB0bCA9IGdzYXAudGltZWxpbmUoe1xuICAgICAgICByZXBlYXQ6IHRoaXMub3B0aW9ucy5sb29wLFxuICAgICAgICByZXBlYXREZWxheTogMFxuICAgICAgfSk7XG4gICAgICBnbGl0Y2hlZC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICB2YXIgcG93ZXIgPSBfdGhpczIub3B0aW9ucy5wb3dlciAqIDQwO1xuICAgICAgICB2YXIgbGF5ZXJUbCA9IGdzYXAudGltZWxpbmUoKTtcbiAgICAgICAgbGF5ZXJUbC50byhpdGVtLCB7XG4gICAgICAgICAgZHVyYXRpb246IDAuMDQsXG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICB4OiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBwb3dlclxuICAgICAgICB9LCBcIis9MC4wNVwiKTtcbiAgICAgICAgbGF5ZXJUbC50byhpdGVtLCB7XG4gICAgICAgICAgZHVyYXRpb246IDAuMDQsXG4gICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICB4OiAwXG4gICAgICAgIH0sIFwiKz0wLjA1XCIpO1xuICAgICAgICBsYXllclRsLnRvKHt9LCB7XG4gICAgICAgICAgZHVyYXRpb246IDAuMVxuICAgICAgICB9KTtcbiAgICAgICAgbGF5ZXJUbC50byhpdGVtLCB7XG4gICAgICAgICAgZHVyYXRpb246IDAuMDQsXG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICB4OiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBwb3dlciAqIDEuNVxuICAgICAgICB9LCBcIis9MFwiKTtcbiAgICAgICAgbGF5ZXJUbC50byhpdGVtLCB7XG4gICAgICAgICAgZHVyYXRpb246IDAuMDQsXG4gICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICB4OiAwXG4gICAgICAgIH0sIFwiKz0wLjA1XCIpO1xuICAgICAgICBsYXllclRsLnRvKHt9LCB7XG4gICAgICAgICAgZHVyYXRpb246IDAuMVxuICAgICAgICB9KTtcbiAgICAgICAgbGF5ZXJUbC50byhpdGVtLCB7XG4gICAgICAgICAgZHVyYXRpb246IDAuMDQsXG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICB4OiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBwb3dlclxuICAgICAgICB9LCBcIis9MFwiKTtcbiAgICAgICAgbGF5ZXJUbC50byhpdGVtLCB7XG4gICAgICAgICAgZHVyYXRpb246IDAuMDQsXG4gICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICB4OiAwXG4gICAgICAgIH0sIFwiKz0wLjA1XCIpO1xuICAgICAgICBsYXllclRsLnRvKHt9LCB7XG4gICAgICAgICAgZHVyYXRpb246IDAuMVxuICAgICAgICB9KTtcbiAgICAgICAgbGF5ZXJUbC50byhpdGVtLCB7XG4gICAgICAgICAgZHVyYXRpb246IDAuMDQsXG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICB4OiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBwb3dlclxuICAgICAgICB9LCBcIis9MC4wNVwiKTtcbiAgICAgICAgbGF5ZXJUbC50byhpdGVtLCB7XG4gICAgICAgICAgZHVyYXRpb246IDAuMDQsXG4gICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICB4OiAwXG4gICAgICAgIH0sIFwiKz0wLjA1XCIpOyAvLyBsYXllclRsLnRvKHt9LCB7ZHVyYXRpb246IChNYXRoLnJhbmRvbSgpLzEwKX0pO1xuXG4gICAgICAgIGxheWVyVGwudG8oe30sIHtcbiAgICAgICAgICBkdXJhdGlvbjogTWF0aC5yYW5kb20oKSAvIDJcbiAgICAgICAgfSk7IC8vIHRsLmFkZCggbGF5ZXJUbCwgaW5kZXgvMjAgKTtcblxuICAgICAgICB0bC5hZGQobGF5ZXJUbCwgMCk7IC8vIHRsLmFkZCggbGF5ZXJUbCwgMC41ICk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgZWxlbWVudHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdlbmVyYXRlRWxlbWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2VuZXJhdGVFbGVtZW50cygpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuY29tcHV0ZWRTdHlsZS53aWR0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDIwOyBpKyspIHtcbiAgICAgICAgdmFyIGNsb25lID0gdGhpcy5vcmlnaW5hbC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIGNsb25lLmNsYXNzTGlzdC5hZGQoJ2dsaXRjaGVkJyk7XG4gICAgICAgIGNsb25lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgY2xvbmUuc3R5bGUudG9wID0gXCJcIi5jb25jYXQoaSAqIDYwLCBcInB4XCIpO1xuICAgICAgICBjbG9uZS5zdHlsZS5sZWZ0ID0gMDtcbiAgICAgICAgY2xvbmUuc3R5bGUud2lkdGggPSB0aGlzLmNvbXB1dGVkU3R5bGUud2lkdGg7IC8vIGNsb25lLnN0eWxlLmhlaWdodCA9ICczMHB4JztcbiAgICAgICAgLy8gY2xvbmUuc3R5bGUuaGVpZ2h0ID0gYCR7NSArIE1hdGgucmFuZG9tKCkqODB9cHhgO1xuXG4gICAgICAgIGNsb25lLnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KDIgKyBNYXRoLnJhbmRvbSgpICogMTAwLCBcInB4XCIpOyAvLyBjbG9uZS5zdHlsZS5maWx0ZXIgPSAnZ3JheXNjYWxlKDUwJSknO1xuICAgICAgICAvLyBjbG9uZS5zdHlsZS5maWx0ZXIgPSBgYnJpZ2h0bmVzcygxLjIpYDtcblxuICAgICAgICBjbG9uZS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICBjbG9uZS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICB2YXIgY2hpbGQgPSBjbG9uZS5maXJzdENoaWxkO1xuICAgICAgICBjaGlsZC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGNoaWxkLnN0eWxlLnRvcCA9IFwiXCIuY29uY2F0KGkgKiAtNjAsIFwicHhcIik7XG4gICAgICAgIGNoaWxkLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICAgICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ4QmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAnR2xpdGNoJyxcbiAgb3B0aW9uczoge1xuICAgIHBvd2VyOiAxLFxuICAgIGxvb3A6IDBcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogRGVidWdnZXIgXSc7XG52YXIgREVCVUcgPSB0cnVlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9GeEJhc2UpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfRnhCYXNlKTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgY29uc29sZS5sb2coJ1xcblxcbicpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRMb2NhbEJvdW5kaW5nQ2xpZW50UmVjdChlbCkge1xuICAgICAgICB2YXIgYSA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgYiA9IGVsLnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGVmdDogYS5sZWZ0IC0gYi5sZWZ0LFxuICAgICAgICAgIHRvcDogYS50b3AgLSBiLnRvcCxcbiAgICAgICAgICB3aWR0aDogYS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGEuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9IC8vIENsaWVudCBSZWN0XG5cblxuICAgICAgdmFyIGNsaWVudFJlY3QgPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zb2xlLmxvZygnY2xpZW50UmVjdDonLCBjbGllbnRSZWN0KTtcbiAgICAgIHZhciBwYXJlbnRDbGllbnRSZWN0ID0gdGhpcy5lbGVtZW50LnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zb2xlLmxvZygncGFyZW50Q2xpZW50UmVjdDonLCBwYXJlbnRDbGllbnRSZWN0KTtcbiAgICAgIGNvbnNvbGUubG9nKCdsb2NhbCByZWN0OicsIGdldExvY2FsQm91bmRpbmdDbGllbnRSZWN0KHRoaXMuZWxlbWVudCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZCgpIHt9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KEZ4QmFzZSk7XG5cbl9kZWZpbmVQcm9wZXJ0eShfZGVmYXVsdCwgXCJtYW5pZmVzdFwiLCB7XG4gIGlkOiAnRGVidWdnZXInLFxuICBvcHRpb25zOiB7XG4gICAgdHJpZ2dlcjogJ2F1dG8nXG4gIH1cbn0pO1xuXG5leHBvcnQgeyBfZGVmYXVsdCBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8vIEV4cGVyaW1lbnRhbCBFZmZlY3RcbmltcG9ydCBGeEJhc2UgZnJvbSAnLi4vRnhCYXNlJztcbnZhciBMT0cgPSAnWyBGWCA6IEdsaXRjaENhbnZhcyBdJztcbnZhciBERUJVRyA9IHRydWU7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Z4QmFzZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9GeEJhc2UpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImluaXRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8tLS1cbiAgICAgIC8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vY29kZXBlbi5pby9CbHVtbWVkL3Blbi9sQ2ppdT9lZGl0b3JzPTAwMTBcbiAgICAgIGNvbnNvbGUubG9nKExPRywgJ29wdGlvbnM6JywgdGhpcy5vcHRpb25zKTsgLy8gR2V0IHRoZSBkZXZpY2UgcGl4ZWwgcmF0aW8sIGZhbGxpbmcgYmFjayB0byAxLlxuXG4gICAgICB2YXIgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTsgLy8gUHJlcGFyZSBlbGVtZW50c1xuXG4gICAgICB0aGlzLm9yaWdpbmFsID0gdGhpcy5lbGVtZW50OyAvLyBsZXQgYm91bmRzID0gdGhpcy5vcmlnaW5hbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIC8vIGxldCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5vcmlnaW5hbCk7XG4gICAgICAvLyBSZXBsYWNlIGVsZW1lbnQgL3cgY2FudmFzXG5cbiAgICAgIHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgdGhpcy5vcmlnaW5hbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmVsZW1lbnQsIHRoaXMub3JpZ2luYWwpO1xuICAgICAgdGhpcy5vcmlnaW5hbC5zdHlsZS5vcGFjaXR5ID0gLjE7XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5lbGVtZW50O1xuICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICAgICAgICBpbWcgPSBuZXcgSW1hZ2UoKSxcbiAgICAgICAgICB3LFxuICAgICAgICAgIGgsXG4gICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgIGdsaXRjaEludGVydmFsLFxuICAgICAgICAgIHNjYWxlO1xuICAgICAgY29udGV4dC5zY2FsZShkcHIsIGRwcik7XG4gICAgICBpbWcuc3JjID0gdGhpcy5vcmlnaW5hbC5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuXG4gICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpbml0KCk7XG4gICAgICAgIHdpbmRvdy5vbnJlc2l6ZSA9IGluaXQ7XG4gICAgICB9O1xuXG4gICAgICB2YXIgaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoZ2xpdGNoSW50ZXJ2YWwpO1xuXG4gICAgICAgIHZhciBib3VuZHMgPSBfdGhpczIub3JpZ2luYWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShfdGhpczIub3JpZ2luYWwpO1xuICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBjb21wdXRlZFN0eWxlLndpZHRoO1xuICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gY29tcHV0ZWRTdHlsZS5oZWlnaHQ7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gY29tcHV0ZWRTdHlsZS5sZWZ0O1xuICAgICAgICBjYW52YXMuc3R5bGUudG9wID0gY29tcHV0ZWRTdHlsZS50b3A7XG4gICAgICAgIGNhbnZhcy5zdHlsZS50cmFuc2Zvcm0gPSBjb21wdXRlZFN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gdyA9IGJvdW5kcy53aWR0aCAqIGRwcjtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGggPSBib3VuZHMuaGVpZ2h0ICogZHByO1xuICAgICAgICBzY2FsZSA9IGltZy53aWR0aCAvIHc7XG4gICAgICAgIGdsaXRjaEludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNsZWFyKCk7XG4gICAgICAgICAgc2V0VGltZW91dChnbGl0Y2hJbWcsIHJhbmRJbnQoMjUwLCAxMDAwKSk7XG4gICAgICAgIH0sIDMwMCk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdyAqIGRwciwgaCAqIGRwcik7XG4gICAgICB9O1xuXG4gICAgICB2YXIgZ2xpdGNoSW1nID0gZnVuY3Rpb24gZ2xpdGNoSW1nKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmRJbnQoMSwgMTMpOyBpKyspIHtcbiAgICAgICAgICB2YXIgeCA9IE1hdGgucmFuZG9tKCkgKiB3ICogZHByO1xuICAgICAgICAgIHZhciB5ID0gTWF0aC5yYW5kb20oKSAqIGggKiBkcHI7XG4gICAgICAgICAgdmFyIHNwbGljZVdpZHRoID0gdyAqIGRwciAtIHg7XG4gICAgICAgICAgdmFyIHNwbGljZUhlaWdodCA9IHJhbmRJbnQoNSwgaCAqIGRwciAvIDMpOyAvLyBjb250ZXh0LmRyYXdJbWFnZShjYW52YXMsIDAsIHksIHNwbGljZVdpZHRoLCBzcGxpY2VIZWlnaHQsIHgsIHksIHNwbGljZVdpZHRoKmRwciwgc3BsaWNlSGVpZ2h0KmRwcik7XG4gICAgICAgICAgLy8gY29udGV4dC5kcmF3SW1hZ2UoY2FudmFzLCBzcGxpY2VXaWR0aCwgeSwgeCwgc3BsaWNlSGVpZ2h0LCAwLCB5LCB4LCBzcGxpY2VIZWlnaHQqZHByKTtcbiAgICAgICAgICAvLyBXT1JLSU5HXG4gICAgICAgICAgLy8gY29udGV4dC5kcmF3SW1hZ2UoaW1nLCAwLCAyMDAsIGltZy53aWR0aCwgMTAwLCAwLCAyMDAvc2NhbGUsIHcsIDEwMC9zY2FsZSk7XG5cbiAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIDAsIDIwMCwgaW1nLndpZHRoLCAxMDAsIDAsIDIwMCAvIHNjYWxlLCB3LCAxMDAgLyBzY2FsZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciByYW5kSW50ID0gZnVuY3Rpb24gcmFuZEludChhLCBiKSB7XG4gICAgICAgIHJldHVybiB+fihNYXRoLnJhbmRvbSgpICogKGIgLSBhKSArIGEpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcImVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQoKSB7fVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufShGeEJhc2UpO1xuXG5fZGVmaW5lUHJvcGVydHkoX2RlZmF1bHQsIFwibWFuaWZlc3RcIiwge1xuICBpZDogJ2dsaXRjaC1jYW52YXMnLFxuICBvcHRpb25zOiB7XG4gICAgdHJpZ2dlcjogJ2hvdmVyJ1xuICB9XG59KTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vLyBFeHBlcmltZW50YWwgRWZmZWN0XG5pbXBvcnQgRnhCYXNlIGZyb20gJy4uL0Z4QmFzZSc7XG52YXIgTE9HID0gJ1sgRlggOiBHbGl0Y2hFYXNlbCBdJztcbnZhciBERUJVRyA9IHRydWU7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Z4QmFzZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9GeEJhc2UpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiY2FudmFzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic3RhZ2VcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImhlaWdodFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImRwclwiLCAhd2luZG93LmRldmljZVBpeGVsUmF0aW8gPyAxIDogd2luZG93LmRldmljZVBpeGVsUmF0aW8gPj0gMiA/IDIgOiAxKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzZWdtZW50c1wiLCBbXSk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImluaXRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8gU2F2ZSBvcmlnaW5hbCBpbWFnZVxuICAgICAgdGhpcy5vcmlnaW5hbCA9IHRoaXMuZWxlbWVudDsgLy8gQ3JlYXRlIGNhbnZhc1xuXG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIHRoaXMuc3RhZ2UgPSBuZXcgY3JlYXRlanMuU3RhZ2UodGhpcy5jYW52YXMpO1xuICAgICAgdGhpcy5vcmlnaW5hbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmNhbnZhcywgdGhpcy5vcmlnaW5hbC5uZXh0U2libGluZyk7XG4gICAgICB0aGlzLm9yaWdpbmFsLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgdGhpcy5vcmlnaW5hbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLm9yaWdpbmFsKTtcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGNvbXB1dGVkU3R5bGUud2lkdGg7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gY29tcHV0ZWRTdHlsZS5oZWlnaHQ7XG4gICAgICBjYW52YXMuc3R5bGUubGVmdCA9IGNvbXB1dGVkU3R5bGUubGVmdDtcbiAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSBjb21wdXRlZFN0eWxlLnRvcDtcbiAgICAgIGNhbnZhcy5zdHlsZS50cmFuc2Zvcm0gPSBjb21wdXRlZFN0eWxlLnRyYW5zZm9ybTsgLy8gY2FudmFzLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG5cbiAgICAgIHRoaXMud2lkdGggPSBwYXJzZUludChjb21wdXRlZFN0eWxlLndpZHRoKSAqIHRoaXMuZHByO1xuICAgICAgdGhpcy5oZWlnaHQgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmhlaWdodCkgKiB0aGlzLmRwcjtcbiAgICAgIHZhciByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc29sZS5sb2coMjIsIHJlY3QpO1xuICAgICAgY2FudmFzLndpZHRoID0gcmVjdC53aWR0aCAqIHRoaXMuZHByO1xuICAgICAgY2FudmFzLmhlaWdodCA9IHJlY3QuaGVpZ2h0ICogdGhpcy5kcHI7XG4gICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5zY2FsZSh0aGlzLmRwciwgdGhpcy5kcHIpO1xuICAgICAgdGhpcy5lbGVtZW50ID0gdGhpcy5jYW52YXM7IC8vIENyZWF0ZSBzZWdtZW50c1xuXG4gICAgICB2YXIgc2VlZEluZGV4ID0gMCxcbiAgICAgICAgICB0b3AgPSAwO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgc2VlZCA9IE1hdGgucm91bmQodGhpcy5vcHRpb25zLnNlZWRbc2VlZEluZGV4XSAqIHRoaXMub3B0aW9ucy5mYWN0b3IpO1xuICAgICAgICB2YXIgaW1hZ2UgPSBuZXcgY3JlYXRlanMuQml0bWFwKHRoaXMub3JpZ2luYWwuZ2V0QXR0cmlidXRlKCdzcmMnKSk7XG4gICAgICAgIHZhciBzaGFwZSA9IG5ldyBjcmVhdGVqcy5TaGFwZSgpO1xuICAgICAgICBzaGFwZS5ncmFwaGljcy5iZWdpbkZpbGwoXCIjRkZGRkZGXCIpLmRyYXdSZWN0KDAsIHRvcCwgdGhpcy53aWR0aCwgc2VlZCk7XG4gICAgICAgIGltYWdlLm1hc2sgPSBzaGFwZTtcbiAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChpbWFnZSk7XG4gICAgICAgIHRoaXMuc2VnbWVudHMucHVzaChpbWFnZSk7IC8vIEVuZFxuXG4gICAgICAgIGlmICh0b3AgPj0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5oZWlnaHQpICogdGhpcy5kcHIpIGJyZWFrOyAvLyBJdGVyYXRlIFxuXG4gICAgICAgIHRvcCArPSBzZWVkO1xuICAgICAgICBzZWVkSW5kZXggPSBzZWVkSW5kZXggPj0gdGhpcy5vcHRpb25zLnNlZWQubGVuZ3RoIC0gMSA/IDAgOiArK3NlZWRJbmRleDtcbiAgICAgIH0gLy8gVGltZWxpbmVcblxuXG4gICAgICB0aGlzLnRpbWVsaW5lID0gZ3NhcC50aW1lbGluZSh7XG4gICAgICAgIHBhdXNlZDogdHJ1ZSxcbiAgICAgICAgZGVsYXk6IHRoaXMub3B0aW9ucy5kZWxheSAvIDEwMDAsXG4gICAgICAgIHJlcGVhdDogdGhpcy5vcHRpb25zLnJlcGVhdCxcbiAgICAgICAgcmVwZWF0RGVsYXk6IHRoaXMub3B0aW9ucy5yZXBlYXREZWxheSAvIDEwMDAsXG4gICAgICAgIHlveW86IHRoaXMub3B0aW9ucy55b3lvLFxuICAgICAgICBvblVwZGF0ZTogdGhpcy5zdGFnZS51cGRhdGUuYmluZCh0aGlzLnN0YWdlKVxuICAgICAgfSk7XG4gICAgICB0aGlzLnNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKHNlZ21lbnQsIGluZGV4KSB7XG4gICAgICAgIF90aGlzMi50aW1lbGluZS5mcm9tKHNlZ21lbnQsIHtcbiAgICAgICAgICB4OiAoTWF0aC5yYW5kb20oKSAtIC41KSAqIDIwICogX3RoaXMyLm9wdGlvbnMucG93ZXIsXG4gICAgICAgICAgYWxwaGE6IDAsXG4gICAgICAgICAgZHVyYXRpb246IDAuNSxcbiAgICAgICAgICBlYXNlOiBfdGhpczIub3B0aW9ucy5lYXNlaW5nXG4gICAgICAgIH0sIFwiXCIuY29uY2F0KGluZGV4ICogX3RoaXMyLm9wdGlvbnMuc3RhZ2dlciAvIDEwMDApKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy50aW1lbGluZS50aW1lU2NhbGUodGhpcy50aW1lbGluZS5kdXJhdGlvbigpIC8gKHRoaXMub3B0aW9ucy5kdXJhdGlvbiAvIDEwMDApKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICB0aGlzLnRpbWVsaW5lLnBsYXkoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZCgpIHtcbiAgICAgIHRoaXMudGltZWxpbmUucmV2ZXJzZSgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICdnbGl0Y2gtZWFzZWwnLFxuICBvcHRpb25zOiB7XG4gICAgdHJpZ2dlcjogJ2hvdmVyJyxcbiAgICBkdXJhdGlvbjogMTAwMCxcbiAgICBkZWxheTogMCxcbiAgICByZXBlYXQ6IDAsXG4gICAgcmVwZWF0RGVsYXk6IDEwMDAsXG4gICAgeW95bzogdHJ1ZSxcbiAgICBzZWVkOiBbMSwgNiwgMywgMSwgMywgOCwgMiwgMSwgOSwgNCwgNywgMV0sXG4gICAgZmFjdG9yOiAxMCxcbiAgICBwb3dlcjogODAsXG4gICAgc3RhZ2dlcjogMTAsXG4gICAgZWFzaW5nOiAncG93ZXI0LmluT3V0JyAvLyBiYWNrLm91dCgzKSxcblxuICB9XG59KTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vLyBFeHBlcmltZW50YWwgRWZmZWN0XG5pbXBvcnQgRnhCYXNlIGZyb20gJy4uL0Z4QmFzZSc7XG52YXIgTE9HID0gJ1sgRlggOiBHbGl0Y2hBcHBlYXIgXSc7XG52YXIgREVCVUcgPSB0cnVlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9GeEJhc2UpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfRnhCYXNlKTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIF90aGlzLm9yaWdpbmFsO1xuICAgIF90aGlzLmNvbXB1dGVkU3R5bGU7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImluaXRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpOyAvLyBzdXBlci5zdGFydCgpO1xuXG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2luaXQoKScsIHRoaXMub3B0aW9ucyk7IC8vIFByZXBhcmUgZWxlbWVudHNcblxuICAgICAgdGhpcy5vcmlnaW5hbCA9IHRoaXMuZWxlbWVudDtcbiAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gdGhpcy5jb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5vcmlnaW5hbCk7IC8vIFdyYXAgZXZlcnl0aGluZyBpbiBkaXZcblxuICAgICAgdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBjb21wdXRlZFN0eWxlLnBvc2l0aW9uO1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoID0gY29tcHV0ZWRTdHlsZS53aWR0aDtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBjb21wdXRlZFN0eWxlLmhlaWdodDtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS50b3AgPSBjb21wdXRlZFN0eWxlLnRvcDtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5sZWZ0ID0gY29tcHV0ZWRTdHlsZS5sZWZ0OyAvLyB0aGlzLmVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNCQURBNTUnO1xuXG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21vam8tZngtZ2xpdGNoJywgdGhpcy5vcmlnaW5hbC5nZXRBdHRyaWJ1dGUoJ21vam8tZngtZ2xpdGNoJykpO1xuICAgICAgdGhpcy5vcmlnaW5hbC5yZW1vdmVBdHRyaWJ1dGUoJ21vam8tZngtZ2xpdGNoJyk7XG4gICAgICB0aGlzLm9yaWdpbmFsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuZWxlbWVudCwgdGhpcy5vcmlnaW5hbCk7XG4gICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5vcmlnaW5hbCk7IC8vIFdyYXAgb3JpZ2luYWwgaW4gZGl2IChmb3IgbWFza2luZyBldGMuKVxuXG4gICAgICB2YXIgbGF5ZXJXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aGlzLm9yaWdpbmFsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGxheWVyV3JhcHBlciwgdGhpcy5vcmlnaW5hbCk7XG4gICAgICBsYXllcldyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5vcmlnaW5hbCk7XG4gICAgICB0aGlzLm9yaWdpbmFsID0gbGF5ZXJXcmFwcGVyOyAvLyBHZW5lcmF0ZSBFbGVtZW50c1xuXG4gICAgICB0aGlzLmdlbmVyYXRlRWxlbWVudHMoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdzdGFydCgpJyk7XG4gICAgICB2YXIgZ2xpdGNoZWQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmdsaXRjaGVkJyk7XG4gICAgICBnc2FwLnNldCh0aGlzLm9yaWdpbmFsLCB7XG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH0pO1xuICAgICAgZ3NhcC5zZXQoZ2xpdGNoZWQsIHtcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSk7XG4gICAgICB2YXIgdGwgPSBnc2FwLnRpbWVsaW5lKHtcbiAgICAgICAgZGVsYXk6IHRoaXMub3B0aW9ucy5kZWxheSAvIDEwMDBcbiAgICAgIH0pO1xuICAgICAgZ2xpdGNoZWQuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgLy8gbGV0IHBvd2VyID0gMjA7XG4gICAgICAgIHZhciBwb3dlciA9IDMwO1xuICAgICAgICB2YXIgbGF5ZXJUbCA9IGdzYXAudGltZWxpbmUoKTtcbiAgICAgICAgbGF5ZXJUbC50byhpdGVtLCB7XG4gICAgICAgICAgZHVyYXRpb246IDAuMDQsXG4gICAgICAgICAgb3BhY2l0eTogMC4yLFxuICAgICAgICAgIHg6IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHBvd2VyXG4gICAgICAgIH0sIFwiKz0wLjAyXCIpO1xuICAgICAgICBsYXllclRsLnRvKGl0ZW0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogMC4wNCxcbiAgICAgICAgICBvcGFjaXR5OiAwLjQsXG4gICAgICAgICAgeDogMFxuICAgICAgICB9LCBcIis9MC4wMlwiKTtcbiAgICAgICAgbGF5ZXJUbC50byhpdGVtLCB7XG4gICAgICAgICAgZHVyYXRpb246IDAuMDQsXG4gICAgICAgICAgb3BhY2l0eTogMC42LFxuICAgICAgICAgIHg6IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHBvd2VyXG4gICAgICAgIH0sIFwiKz0wXCIpO1xuICAgICAgICBsYXllclRsLnRvKGl0ZW0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogMC4wNCxcbiAgICAgICAgICBvcGFjaXR5OiAwLjgsXG4gICAgICAgICAgeDogMFxuICAgICAgICB9LCBcIis9MC4wMlwiKTtcbiAgICAgICAgbGF5ZXJUbC50byh7fSwge1xuICAgICAgICAgIGR1cmF0aW9uOiAwLjAyXG4gICAgICAgIH0pO1xuICAgICAgICBsYXllclRsLnRvKGl0ZW0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogMC4wNCxcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIHg6IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHBvd2VyXG4gICAgICAgIH0sIFwiKz0wXCIpOyAvLyBsYXllclRsLnRvKGl0ZW0sIHtkdXJhdGlvbjogMC4wNCwgb3BhY2l0eTogMSwgeDogMH0sIGArPTAuMDJgKTtcbiAgICAgICAgLy8gbGF5ZXJUbC50byhpdGVtLCB7ZHVyYXRpb246IDAuMDQsIG9wYWNpdHk6IDEsIHg6IChNYXRoLnJhbmRvbSgpLTAuNSkqcG93ZXJ9LCBgKz0wLjAyYCk7XG5cbiAgICAgICAgbGF5ZXJUbC50byhpdGVtLCB7XG4gICAgICAgICAgZHVyYXRpb246IDAuMDQsXG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICB4OiAwXG4gICAgICAgIH0sIFwiKz0wLjAyXCIpO1xuICAgICAgICB0bC5hZGQobGF5ZXJUbCwgaW5kZXggLyAxMCk7IC8vIHRsLmFkZCggbGF5ZXJUbCwgMC41ICk7XG4gICAgICB9KTsgLy8gdGwudG8odGhpcy5vcmlnaW5hbCwge2R1cmF0aW9uOiAwLjIsIG9wYWNpdHk6IDF9LCAuNSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQoKSB7fVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGVsZW1lbnRzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZUVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlRWxlbWVudHMoKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmNvbXB1dGVkU3R5bGUud2lkdGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIHZhciBjbG9uZSA9IHRoaXMub3JpZ2luYWwuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICBjbG9uZS5jbGFzc0xpc3QuYWRkKCdnbGl0Y2hlZCcpO1xuICAgICAgICBjbG9uZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGNsb25lLnN0eWxlLnRvcCA9IFwiXCIuY29uY2F0KGkgKiA2MCwgXCJweFwiKTtcbiAgICAgICAgY2xvbmUuc3R5bGUubGVmdCA9IDA7XG4gICAgICAgIGNsb25lLnN0eWxlLndpZHRoID0gdGhpcy5jb21wdXRlZFN0eWxlLndpZHRoOyAvLyBjbG9uZS5zdHlsZS5oZWlnaHQgPSAnMzBweCc7XG5cbiAgICAgICAgY2xvbmUuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQoNSArIE1hdGgucmFuZG9tKCkgKiA4MCwgXCJweFwiKTsgLy8gY2xvbmUuc3R5bGUuZmlsdGVyID0gJ2dyYXlzY2FsZSgxMCUpJztcbiAgICAgICAgLy8gY2xvbmUuc3R5bGUuZmlsdGVyID0gYGJyaWdodG5lc3MoMS4wNClgO1xuXG4gICAgICAgIGNsb25lLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgIHZhciBjaGlsZCA9IGNsb25lLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGNoaWxkLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgY2hpbGQuc3R5bGUudG9wID0gXCJcIi5jb25jYXQoaSAqIC02MCwgXCJweFwiKTtcbiAgICAgICAgY2hpbGQuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICdHbGl0Y2hBcHBlYXInLFxuICBvcHRpb25zOiB7XG4gICAgZGVsYXk6IDBcbiAgfVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogR2xpdGNoQmFzZSBdJztcbnZhciBERUJVRyA9IHRydWU7XG5cbnZhciBfZGVmYXVsdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Z4QmFzZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9GeEJhc2UpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgX3RoaXMub3JpZ2luYWw7XG4gICAgX3RoaXMuY29tcHV0ZWRTdHlsZTtcbiAgICBfdGhpcy5zZWdtZW50cyA9IFtdO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnaW5pdCgpJywgdGhpcy5vcHRpb25zKTsgLy8gUHJlcGFyZSBlbGVtZW50c1xuXG4gICAgICB0aGlzLm9yaWdpbmFsID0gdGhpcy5lbGVtZW50O1xuICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSB0aGlzLmNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLm9yaWdpbmFsKTsgLy8gV3JhcCBldmVyeXRoaW5nIGluIGRpdlxuXG4gICAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IGNvbXB1dGVkU3R5bGUucG9zaXRpb247XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSBjb21wdXRlZFN0eWxlLndpZHRoO1xuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IGNvbXB1dGVkU3R5bGUuaGVpZ2h0OyAvLyBJZ25vcmUgdHJhbnNmb3Jtc1xuXG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUudG9wID0gY29tcHV0ZWRTdHlsZS50b3A7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUubGVmdCA9IGNvbXB1dGVkU3R5bGUubGVmdDtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBjb21wdXRlZFN0eWxlLnRyYW5zZm9ybTsgLy8gSW5jb3Jwb3JhdGUgdHJhbnNmb3Jtc1xuICAgICAgLy8gY29uc29sZS5sb2coJ2JvdW5kJywgYm91bmQpO1xuICAgICAgLy8gdGhpcy5lbGVtZW50LnN0eWxlLnRvcCA9IGJvdW5kLnRvcCsncHgnO1xuICAgICAgLy8gdGhpcy5lbGVtZW50LnN0eWxlLmxlZnQgPSBib3VuZC5sZWZ0KydweCc7XG4gICAgICAvLyB0aGlzLmVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNCQURBNTUnO1xuICAgICAgLy8gdGhpcy5lbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG5cbiAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21vam8tZngtZ2xpdGNoJywgdGhpcy5vcmlnaW5hbC5nZXRBdHRyaWJ1dGUoJ21vam8tZngtZ2xpdGNoJykpO1xuICAgICAgdGhpcy5vcmlnaW5hbC5yZW1vdmVBdHRyaWJ1dGUoJ21vam8tZngtZ2xpdGNoJyk7XG4gICAgICB0aGlzLm9yaWdpbmFsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICB0aGlzLm9yaWdpbmFsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuZWxlbWVudCwgdGhpcy5vcmlnaW5hbCk7XG4gICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5vcmlnaW5hbCk7IC8vIFdyYXAgb3JpZ2luYWwgaW4gZGl2IChmb3IgbWFza2luZyBldGMuKVxuXG4gICAgICB2YXIgbGF5ZXJXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBsYXllcldyYXBwZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgIHRoaXMub3JpZ2luYWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobGF5ZXJXcmFwcGVyLCB0aGlzLm9yaWdpbmFsKTtcbiAgICAgIGxheWVyV3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLm9yaWdpbmFsKTtcbiAgICAgIHRoaXMub3JpZ2luYWwgPSBsYXllcldyYXBwZXI7IC8vIEdlbmVyYXRlIEVsZW1lbnRzXG5cbiAgICAgIHRoaXMuZ2VuZXJhdGVFbGVtZW50cygpO1xuICAgICAgY29uc29sZS5sb2coTE9HLCAnZ2VuZXJhdGVkJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge31cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge31cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBlbGVtZW50c1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2VuZXJhdGVFbGVtZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZUVsZW1lbnRzKCkge1xuICAgICAgLy8gY29uc29sZS5sb2codGhpcy5jb21wdXRlZFN0eWxlLndpZHRoKTtcbiAgICAgIHZhciBzZWVkSW5kZXggPSAwLFxuICAgICAgICAgIHRvcCA9IDAsXG4gICAgICAgICAgaSA9IDA7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBzZWVkID0gdGhpcy5vcHRpb25zLnNlZWRbc2VlZEluZGV4XSAqIHRoaXMub3B0aW9ucy5mYWN0b3I7XG4gICAgICAgIHZhciBjbG9uZSA9IHRoaXMub3JpZ2luYWwuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICBjbG9uZS5jbGFzc0xpc3QuYWRkKCdnbGl0Y2hlZCcpO1xuICAgICAgICBjbG9uZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGNsb25lLnN0eWxlLnRvcCA9IFwiXCIuY29uY2F0KHRvcCwgXCJweFwiKTtcbiAgICAgICAgY2xvbmUuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgICBjbG9uZS5zdHlsZS53aWR0aCA9IHRoaXMuY29tcHV0ZWRTdHlsZS53aWR0aDsgLy8gY2xvbmUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ0RlZXBQaW5rJztcblxuICAgICAgICBjbG9uZS5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdChzZWVkLCBcInB4XCIpOyAvLyBjbG9uZS5zdHlsZS5maWx0ZXIgPSAnZ3JheXNjYWxlKDEwMCUpJztcbiAgICAgICAgLy8gY2xvbmUuc3R5bGUuZmlsdGVyID0gYGJyaWdodG5lc3MoMS4wNClgO1xuXG4gICAgICAgIGNsb25lLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgIGNsb25lLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgIHZhciBjaGlsZCA9IGNsb25lLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGNoaWxkLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgY2hpbGQuc3R5bGUudG9wID0gXCItXCIuY29uY2F0KHRvcCwgXCJweFwiKTtcbiAgICAgICAgY2hpbGQuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgICBjaGlsZC5zdHlsZS50cmFuc2Zvcm0gPSAnbm9uZSc7XG4gICAgICAgIGNoaWxkLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuc2VnbWVudHMucHVzaChjbG9uZSk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChjbG9uZSk7IC8vIEVuZFxuXG4gICAgICAgIGlmICh0b3AgPj0gcGFyc2VJbnQodGhpcy5jb21wdXRlZFN0eWxlLmhlaWdodCkpIGJyZWFrOyAvLyBJdGVyYXRlXG4gICAgICAgIC8vIHRvcCArPSBzZWVkO1xuXG4gICAgICAgIHRvcCArPSBzZWVkIC0gMTsgLy8gTm90ZTogV2UgbmVlZCAxcHggb3ZlcmxhcHBpbmcgdG8gcHJldmVudCB3aGl0ZSBsaW5lcyB3aGVuIHNjYWxpbmcgKHJvdW5kaW5nIGlzc3VlKVxuXG4gICAgICAgIHNlZWRJbmRleCA9IHNlZWRJbmRleCA+PSB0aGlzLm9wdGlvbnMuc2VlZC5sZW5ndGggLSAxID8gMCA6ICsrc2VlZEluZGV4O1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufShGeEJhc2UpO1xuXG5fZGVmaW5lUHJvcGVydHkoX2RlZmF1bHQsIFwibWFuaWZlc3RcIiwge1xuICBpZDogJ2dsaXRjaC1iYXNlJyxcbiAgb3B0aW9uczoge1xuICAgIGRlbGF5OiAwLFxuICAgIHNlZWQ6IFsxLCA2LCAzLCAxLCAzLCA4LCAyLCAxLCA5LCA0LCA3LCAxXSxcbiAgICBmYWN0b3I6IDIwXG4gIH1cbn0pO1xuXG5leHBvcnQgeyBfZGVmYXVsdCBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8vIEV4cGVyaW1lbnRhbCBFZmZlY3RcbmltcG9ydCBHbGl0Y2hCYXNlIGZyb20gJy4vR2xpdGNoQmFzZSc7XG52YXIgTE9HID0gJ1sgRlggOiBHbGl0Y2hJbk91dCBdJztcbnZhciBERUJVRyA9IGZhbHNlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9HbGl0Y2hCYXNlKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX0dsaXRjaEJhc2UpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgX3RoaXMudGltZWxpbmU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2luaXQoKScsIHRoaXMub3B0aW9ucyk7XG4gICAgICB0aGlzLm9yaWdpbmFsLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgdGhpcy50aW1lbGluZSA9IGdzYXAudGltZWxpbmUoe1xuICAgICAgICBwYXVzZWQ6IHRydWUsXG4gICAgICAgIGRlbGF5OiB0aGlzLm9wdGlvbnMuZGVsYXkgLyAxMDAwXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgaXRlbS5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgZ3NhcC5zZXQoaXRlbSwge1xuICAgICAgICAgIHg6IChNYXRoLnJhbmRvbSgpIC0gLjUpICogMjAgKiBfdGhpczIub3B0aW9ucy5wb3dlcixcbiAgICAgICAgICBmb3JjZTNEOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIF90aGlzMi50aW1lbGluZS50byhpdGVtLCB7XG4gICAgICAgICAgZHVyYXRpb246IDAuNCxcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgZWFzZTogJ1Bvd2VyNC5pbk91dCcsXG4gICAgICAgICAgZm9yY2UzRDogdHJ1ZVxuICAgICAgICB9LCAwKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ3N0YXJ0KCknKTtcbiAgICAgIHRoaXMudGltZWxpbmUucGxheSgpOyAvLyBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAvLyAgIHRoaXMudGltZWxpbmUucmV2ZXJzZSgpXG4gICAgICAvLyB9LCB0aGlzLm9wdGlvbnMuZGVsYXkrMTkwMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQoKSB7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdlbmQoKScpO1xuICAgICAgdGhpcy50aW1lbGluZS5yZXZlcnNlKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufShHbGl0Y2hCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICdnbGl0Y2gtaW4tb3V0JyxcbiAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLCBcIm1hbmlmZXN0XCIsIF9kZWZhdWx0KS5vcHRpb25zLCB7XG4gICAgdHJpZ2dlcjogJ2F1dG8nLFxuICAgIGRlbGF5OiAwLFxuICAgIHNlZWQ6IFsxLCA2LCAzLCAxLCAzLCA4LCAyLCAxLCA5LCA0LCA3LCAxXSxcbiAgICBmYWN0b3I6IDIwLFxuICAgIHBvd2VyOiA0MFxuICB9KVxufSk7XG5cbmV4cG9ydCB7IF9kZWZhdWx0IGFzIGRlZmF1bHQgfTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLy8gRXhwZXJpbWVudGFsIEVmZmVjdFxuaW1wb3J0IEZ4QmFzZSBmcm9tICcuLi9GeEJhc2UnO1xudmFyIExPRyA9ICdbIEZYIDogUmVtb3ZlIF0nO1xudmFyIERFQlVHID0gdHJ1ZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRnhCYXNlKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX0Z4QmFzZSk7XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblxuICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0LnByb3RvdHlwZSksIFwiaW5pdFwiLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSkuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ29wdGlvbnM6JywgdGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMuZWxlbWVudC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge31cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge31cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICdyZW1vdmUnLFxuICBvcHRpb25zOiB7XG4gICAgdHJpZ2dlcjogJ2F1dG8nXG4gIH1cbn0pO1xuXG5leHBvcnQgeyBfZGVmYXVsdCBhcyBkZWZhdWx0IH07IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8vIEV4cGVyaW1lbnRhbCBFZmZlY3RcbmltcG9ydCBGeEJhc2UgZnJvbSAnLi4vRnhCYXNlJztcbnZhciBMT0cgPSAnWyBGWCA6IFBhblpvb20gXSc7XG52YXIgREVCVUcgPSB0cnVlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9GeEJhc2UpIHtcbiAgX2luaGVyaXRzKF9kZWZhdWx0LCBfRnhCYXNlKTtcblxuICBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgX2RlZmF1bHQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGNvbnNvbGUubG9nKExPRywgJ29wdGlvbnM6JywgdGhpcy5vcHRpb25zKTsgLy8gVEVNUDogWEQgSEFDS1xuXG4gICAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCBibGFjayc7IC8vIEdldCBzdG9wc1xuXG4gICAgICB2YXIgc3RvcEVsZW1lbnRzID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1ttb2pvLWZ4LXBhbnpvb20tc3RvcF0nKTtcbiAgICAgIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ3N0b3BFbGVtZW50czonLCBzdG9wRWxlbWVudHMpOyAvLyBQcm9jZXNzIHN0b3BzXG5cbiAgICAgIHRoaXMuc3RvcHMgPSBbXTtcbiAgICAgIHN0b3BFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBzdG9wID0ge1xuICAgICAgICAgIGVsOiBpdGVtLFxuICAgICAgICAgIHNjYWxlOiBfdGhpczIuZWxlbWVudC5vZmZzZXRXaWR0aCAvIGl0ZW0ub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgbGVmdDogcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoaXRlbSkudHJhbnNmb3JtLnNwbGl0KCcoJylbMV0uc3BsaXQoJywnKVs0XSksXG4gICAgICAgICAgdG9wOiBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpdGVtKS50cmFuc2Zvcm0uc3BsaXQoJygnKVsxXS5zcGxpdCgnLCcpWzVdKVxuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzMi5zdG9wcy5wdXNoKHN0b3ApO1xuXG4gICAgICAgIGl0ZW0uc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIGl0ZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgIH0pO1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnc3RvcHM6JywgdGhpcy5zdG9wcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHRoaXMudGltZWxpbmUgPSBnc2FwLnRpbWVsaW5lKCk7XG4gICAgICB0aGlzLnN0b3BzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgX3RoaXMzLnRpbWVsaW5lLnRvKF90aGlzMy5lbGVtZW50LCB7XG4gICAgICAgICAgc2NhbGU6IGl0ZW0uc2NhbGUsXG4gICAgICAgICAgeDogLWl0ZW0ubGVmdCAqIGl0ZW0uc2NhbGUsXG4gICAgICAgICAgeTogLWl0ZW0udG9wICogaXRlbS5zY2FsZSxcbiAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46ICcwIDAnLFxuICAgICAgICAgIGRlbGF5OiAuNSxcbiAgICAgICAgICBkdXJhdGlvbjogMVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge31cbiAgfV0pO1xuXG4gIHJldHVybiBfZGVmYXVsdDtcbn0oRnhCYXNlKTtcblxuX2RlZmluZVByb3BlcnR5KF9kZWZhdWx0LCBcIm1hbmlmZXN0XCIsIHtcbiAgaWQ6ICdwYW56b29tJyxcbiAgb3B0aW9uczoge1xuICAgIHRyaWdnZXI6ICdhdXRvJ1xuICB9XG59KTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5pbXBvcnQgTmFub0V2ZW50cyBmcm9tICcuLi8uLi9saWJzL25hbm9ldmVudHMnO1xudmFyIExPRyA9ICdbIFBsdWdpbkJhc2UgXSc7XG52YXIgREVCVUcgPSB0cnVlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9OYW5vRXZlbnRzKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX05hbm9FdmVudHMpO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KHNjZW5lLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0KS5jYWxsKHRoaXMpKTtcbiAgICBfdGhpcy5zY2VuZSA9IHNjZW5lO1xuICAgIF90aGlzLnBsYXllciA9IHNjZW5lLnBsYXllcjtcbiAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIFt7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24odGhpcy5tYW5pZmVzdC5vcHRpb25zLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufShOYW5vRXZlbnRzKTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vLyBFeHBlcmltZW50YWwgUGx1Z2luXG5pbXBvcnQgUGx1Z2luQmFzZSBmcm9tICcuLi9QbHVnaW5CYXNlJztcbmltcG9ydCBDb25zdCBmcm9tICcuLi8uLi9Db25zdCc7XG52YXIgTE9HID0gJ1sgUGx1Z2luIDogVmlzdWFsRGVidWdnZXIgXSc7XG52YXIgREVCVUcgPSBmYWxzZTtcblxudmFyIF9kZWZhdWx0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUGx1Z2luQmFzZSkge1xuICBfaW5oZXJpdHMoX2RlZmF1bHQsIF9QbHVnaW5CYXNlKTtcblxuICBfY3JlYXRlQ2xhc3MoX2RlZmF1bHQsIG51bGwsIFt7XG4gICAga2V5OiBcIm1hbmlmZXN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hbmlmZXN0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6ICd2aXN1YWxEZWJ1Z2dlcicsXG4gICAgICAgIG9wdGlvbnM6IHt9XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBfZGVmYXVsdCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdCkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgX3RoaXMubWFuaWZlc3QgPSBfdGhpcy5jb25zdHJ1Y3Rvci5tYW5pZmVzdCgpO1xuXG4gICAgX2dldChfZ2V0UHJvdG90eXBlT2YoX2RlZmF1bHQucHJvdG90eXBlKSwgXCJpbml0XCIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKS5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgW3tcbiAgICBrZXk6IFwiaW5pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnaW5pdCgpJyk7XG4gICAgICB0aGlzLnNjZW5lLm9uKENvbnN0LlNDRU5FX1BSRV9SRUFEWSwgdGhpcy5vbl9zY2VuZV9wcmVSZWFkeS5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuc2NlbmUub24oQ29uc3QuU0NFTkVfUkVBRFksIHRoaXMub25fc2NlbmVfcmVhZHkuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG9uX3NjZW5lX3ByZVJlYWR5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJvbl9zY2VuZV9wcmVSZWFkeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbl9zY2VuZV9wcmVSZWFkeSgpIHt9XG4gICAgLyoqXG4gICAgICogb25fc2NlbmVfcmVhZHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uX3NjZW5lX3JlYWR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uX3NjZW5lX3JlYWR5KCkge1xuICAgICAgdmFyIGNsb25lID0gdGhpcy5zY2VuZS5jb250ZW50LmNsb25lTm9kZShmYWxzZSk7XG4gICAgICBjbG9uZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgdGhpcy5zY2VuZS5jb250ZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKSk7XG4gICAgICBjbG9uZS5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkIHJnYmEoMCwwLDAsLjIpJztcbiAgICAgIGNsb25lLnN0eWxlLmJveFNpemluZyA9ICdib3JkZXItYm94JztcbiAgICAgIGNsb25lLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICB0aGlzLnNjZW5lLmNvbnRlbnQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIF9kZWZhdWx0O1xufShQbHVnaW5CYXNlKTtcblxuZXhwb3J0IHsgX2RlZmF1bHQgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG4vLyBFeHBlcmltZW50YWwgUGx1Z2luXG5pbXBvcnQgUGx1Z2luQmFzZSBmcm9tICcuLi9QbHVnaW5CYXNlJztcbmltcG9ydCBDb25zdCBmcm9tICcuLi8uLi9Db25zdCc7XG52YXIgTE9HID0gJ1sgUGx1Z2luIDogUGFub3JhbWEgXSc7XG52YXIgREVCVUcgPSB0cnVlO1xuXG52YXIgX2RlZmF1bHQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9QbHVnaW5CYXNlKSB7XG4gIF9pbmhlcml0cyhfZGVmYXVsdCwgX1BsdWdpbkJhc2UpO1xuXG4gIF9jcmVhdGVDbGFzcyhfZGVmYXVsdCwgbnVsbCwgW3tcbiAgICBrZXk6IFwibWFuaWZlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFuaWZlc3QoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogJ3Bhbm9yYW1hJyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHNwZWVkOiAxXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIF9kZWZhdWx0KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKF9kZWZhdWx0KS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICBfdGhpcy5tYW5pZmVzdCA9IF90aGlzLmNvbnN0cnVjdG9yLm1hbmlmZXN0KCk7XG5cbiAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihfZGVmYXVsdC5wcm90b3R5cGUpLCBcImluaXRcIiwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpLmNhbGwoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuXG4gICAgX3RoaXMubW91c2VYO1xuICAgIF90aGlzLmxhc3RTY3JvbGxUbyA9IDA7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKF9kZWZhdWx0LCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdpbml0KCknKTtcbiAgICAgIHRoaXMuc2NlbmUub24oQ29uc3QuU0NFTkVfUFJFX1JFQURZLCB0aGlzLm9uX3NjZW5lX3ByZVJlYWR5LmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5zY2VuZS5vbihDb25zdC5TQ0VORV9SRUFEWSwgdGhpcy5vbl9zY2VuZV9yZWFkeS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogb25fc2NlbmVfcHJlUmVhZHlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uX3NjZW5lX3ByZVJlYWR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uX3NjZW5lX3ByZVJlYWR5KCkge1xuICAgICAgLy8gUHJlcGFyZSBzY2VuZVxuICAgICAgdGhpcy5zY2VuZS5lbGVtZW50LnN0eWxlLm92ZXJmbG93WCA9ICdzY3JvbGwnO1xuICAgICAgdGhpcy5zY2VuZS5jb250ZW50LnN0eWxlLm92ZXJmbG93ID0gJ3Vuc2V0JzsgLy8gLy8gVHdlYWsgY29udGVudCBjb250YWluZXIgdG8gZ2V0IHJlYWwgd2lkdGhcbiAgICAgIC8vIC8vIHNjZW5lLmNvbnRlbnQuc3R5bGUud2lkdGggPSAnYXV0byc7XG4gICAgICAvLyBzY2VuZS5jb250ZW50LnN0eWxlLnJpZ2h0ID0gJ3Vuc2V0JztcbiAgICAgIC8vIC8vIFByZXZlbnQgaGlzdG9yeSBiYWNrIHdoZW4gc2Nyb2xsaW5nIHRvIGxlZnQgb24gdmlld3BvcnRcbiAgICAgIC8vIC8vICNUT0RPOiBOb3QgcHJldmVudGluZyBpbiBFZGdlXG4gICAgICAvLyBzY2VuZS5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgIC8vICAgaWYgKGV2dC5jdXJyZW50VGFyZ2V0LnNjcm9sbExlZnQgPD0gMCAmJiBldnQuZGVsdGFYIDwgMCkgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgLy8gfSwge3Bhc3NpdmU6IGZhbHNlfSk7XG4gICAgICAvLyAjVE9ETzogREVDSURFIE9OIFRIUk9UVExFXG5cbiAgICAgIHRoaXMuc2NlbmUuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb2pvLkZ1c2lvbkhlbHBlci50aHJvdHRsZSh0aGlzLm9uX3NjZW5lX21vdXNlTW92ZS5iaW5kKHRoaXMpLCA1MCkpOyAvLyAyMGZwc1xuXG4gICAgICB0aGlzLnNjZW5lLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLm9uX3NjZW5lX2NsaWNrLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBvbl9zY2VuZV9yZWFkeVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25fc2NlbmVfcmVhZHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25fc2NlbmVfcmVhZHkoKSB7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdvbl9zY2VuZV9yZWFkeSgpJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIG9uX3NjZW5lX21vdXNlTW92ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25fc2NlbmVfbW91c2VNb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uX3NjZW5lX21vdXNlTW92ZShldnQpIHtcbiAgICAgIHRoaXMubW91c2VYID0gZXZ0LmNsaWVudFggLSB0aGlzLnNjZW5lLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogb25fc2NlbmVfY2xpY2tcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uX3NjZW5lX2NsaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uX3NjZW5lX2NsaWNrKGV2dCkge1xuICAgICAgLy8gQmFpbCBpZiBtb3VzZSBpcyBvbiBpbnRlcmFjdGl2ZSBlbGVtZW50c1xuICAgICAgaWYgKGV2dC50YXJnZXQuaGFzQXR0cmlidXRlKCdtb2pvLWludGVyYWN0aXZlJykpIHJldHVybjsgLy8gQmFpbCBpZiBhbHJlYWR5IG1vdmluZy9zY3JvbGxpbmdcblxuICAgICAgaWYgKGdzYXAuaXNUd2VlbmluZyh0aGlzLnNjZW5lLmVsZW1lbnQpKSByZXR1cm47XG4gICAgICB2YXIgc2NlbmUgPSB0aGlzLnNjZW5lOyAvLyBEZXRlcm1pbmUgZGlyZWN0aW9uXG5cbiAgICAgIHZhciBtaW5TY3JvbGxUbyA9IDA7XG4gICAgICB2YXIgbWF4U2Nyb2xsVG8gPSBNYXRoLnJvdW5kKHNjZW5lLmNvbnRlbnQuc2Nyb2xsV2lkdGggKiBzY2VuZS5zY2FsZSAtIHNjZW5lLmVsZW1lbnQuY2xpZW50V2lkdGgpO1xuICAgICAgdmFyIGRpciA9IHRoaXMubW91c2VYIC0gc2NlbmUuZWxlbWVudC5jbGllbnRXaWR0aCAvIDIgPiAwID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgIGRpciA9IHNjZW5lLmVsZW1lbnQuc2Nyb2xsTGVmdCA8PSBtaW5TY3JvbGxUbyA/ICdyaWdodCcgOiBkaXI7XG4gICAgICBkaXIgPSBzY2VuZS5lbGVtZW50LnNjcm9sbExlZnQgPj0gbWF4U2Nyb2xsVG8gPyAnbGVmdCcgOiBkaXI7XG4gICAgICBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdkaXI6JywgZGlyKTsgLy8tLS1cbiAgICAgIC8vIHN0ZXAgPSBzY2VuZSB3aWR0aFxuICAgICAgLy8gdmFyIGN1cnJlbnRJbmRleCA9IE1hdGgucm91bmQoc2NlbmUuZWxlbWVudC5zY3JvbGxMZWZ0LyhzY2VuZS5kYXRhLndpZHRoICogc2NlbmUuc2NhbGUpKTtcbiAgICAgIC8vIHZhciBzY3JvbGxUbyA9ICgoZGlyPT0nbGVmdCcpID8gY3VycmVudEluZGV4LTEgOiBjdXJyZW50SW5kZXgrMSkgKiAoc2NlbmUuZGF0YS53aWR0aCAqIHNjZW5lLnNjYWxlKTtcbiAgICAgIC8vIHNjcm9sbFRvID0gKHNjcm9sbFRvIDw9IG1pblNjcm9sbFRvKSA/ICcwJyA6IHNjcm9sbFRvO1xuICAgICAgLy8gc2Nyb2xsVG8gPSAoc2Nyb2xsVG8gPiBtYXhTY3JvbGxUbykgPyBtYXhTY3JvbGxUbyA6IHNjcm9sbFRvO1xuICAgICAgLy8tLS1cbiAgICAgIC8vIHN0ZXAgPSBjdXN0b20gc3RvcHNcblxuICAgICAgdmFyIHN0b3BzID0gdGhpcy5vcHRpb25zLnN0b3BzO1xuICAgICAgaWYgKCFzdG9wcykgY29uc29sZS5lcnJvcihMT0csICdtaXNzaW5nIG9wdGlvbnMgXCJzdG9wc1wiJyk7XG4gICAgICBzdG9wcyA9IHN0b3BzLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh4ICogc2NlbmUuc2NhbGUpO1xuICAgICAgfSk7XG4gICAgICBzdG9wcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgIH0pO1xuICAgICAgREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnc3RvcHMnLCBzdG9wcyk7XG4gICAgICB2YXIgY3VycmVudFNjcm9sbENlbnRlciA9IE1hdGgucm91bmQoc2NlbmUuZWxlbWVudC5zY3JvbGxMZWZ0ICsgc2NlbmUuZWxlbWVudC5jbGllbnRXaWR0aCAvIDIgLSAoc2NlbmUuZWxlbWVudC5jbGllbnRXaWR0aCAtIHNjZW5lLmNvbnRlbnQuY2xpZW50V2lkdGggKiBzY2VuZS5zY2FsZSkgLyAyKTsgLy8gREVCVUcgJiYgY29uc29sZS5sb2coTE9HLCAnY3VycmVudFNjcm9sbENlbnRlcicsIGN1cnJlbnRTY3JvbGxDZW50ZXIpO1xuXG4gICAgICB2YXIgc2Nyb2xsVG87XG4gICAgICB2YXIgc3RvcCA9IDA7XG5cbiAgICAgIGlmIChkaXIgPT0gJ2xlZnQnKSB7XG4gICAgICAgIC8vIEZpbmQgbmV4dCBzbWFsbGVyIHN0b3AgKHJlbGF0aXZlIHRvIGN1cnJlbnQgc2Nyb2xsIGNlbnRlcilcbiAgICAgICAgdmFyIHN0b3BzUmV2ZXJzZSA9IHN0b3BzLnNsaWNlKDApLnJldmVyc2UoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0b3BzUmV2ZXJzZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBpdGVtID0gc3RvcHNSZXZlcnNlW2ldO1xuXG4gICAgICAgICAgaWYgKGl0ZW0gPCBjdXJyZW50U2Nyb2xsQ2VudGVyKSB7XG4gICAgICAgICAgICBzdG9wID0gaXRlbTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmluZCBuZXh0IGhpZ2hlciBzdG9wIChyZWxhdGl2ZSB0byBjdXJyZW50IHNjcm9sbCBjZW50ZXIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IHN0b3BzW2ldO1xuXG4gICAgICAgICAgaWYgKGl0ZW0gPiBjdXJyZW50U2Nyb2xsQ2VudGVyICsgMSkge1xuICAgICAgICAgICAgc3RvcCA9IGl0ZW07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ2FsY3VsYXRlIHNjcm9sbCBuZXcgcG9zaXRpb25cblxuXG4gICAgICBzY3JvbGxUbyA9IE1hdGguZmxvb3Ioc3RvcCAtIHNjZW5lLmVsZW1lbnQuY2xpZW50V2lkdGggLyAyICsgKHNjZW5lLmVsZW1lbnQuY2xpZW50V2lkdGggLSBzY2VuZS5jb250ZW50LmNsaWVudFdpZHRoICogc2NlbmUuc2NhbGUpIC8gMik7XG4gICAgICBzY3JvbGxUbyA9IHNjcm9sbFRvIDw9IG1pblNjcm9sbFRvID8gJzAnIDogc2Nyb2xsVG87XG4gICAgICBzY3JvbGxUbyA9IHNjcm9sbFRvID4gbWF4U2Nyb2xsVG8gPyBtYXhTY3JvbGxUbyA6IHNjcm9sbFRvOyAvLyBERUJVRyAmJiBjb25zb2xlLmxvZyhMT0csICdzY3JvbGxUbycsIHNjcm9sbFRvKTtcbiAgICAgIC8vIER1cmF0aW9uIHJlbGF0aXZlIHRvIGRpc3RhbmNlXG5cbiAgICAgIHZhciBkdXJhdGlvbiA9IE1hdGguYWJzKHRoaXMubGFzdFNjcm9sbFRvIC0gc2Nyb2xsVG8pIC8gMTIwMCAvIHRoaXMub3B0aW9ucy5zcGVlZDtcbiAgICAgIGR1cmF0aW9uID0gZHVyYXRpb24gPCAuMiA/IC4yIDogZHVyYXRpb247IC8vIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ3NwZWVkJywgdGhpcy5vcHRpb25zLnNwZWVkKTtcbiAgICAgIC8vIERFQlVHICYmIGNvbnNvbGUubG9nKExPRywgJ2R1cmF0aW9uJywgZHVyYXRpb24pO1xuICAgICAgLy8gUmVtZW1iZXJcblxuICAgICAgdGhpcy5sYXN0U2Nyb2xsVG8gPSBzY3JvbGxUbzsgLy8gVHdlZW4gICAgXG5cbiAgICAgIGdzYXAuaXNUd2VlbmluZyhzY2VuZS5lbGVtZW50KSAmJiBnc2FwLmtpbGxUd2VlbnNPZihzY2VuZS5lbGVtZW50KTtcbiAgICAgIGdzYXAudG8oc2NlbmUuZWxlbWVudCwge1xuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIGVhc2U6ICdwb3dlcjQuaW5PdXQnLFxuICAgICAgICBzY3JvbGxMZWZ0OiBzY3JvbGxUbyxcbiAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICAvLyB1cGRhdGVDdXJzb3JEaXIoKTtcbiAgICAgICAgICAvLyBQcm9wYWdhdGUgY3VzdG9tX3NsaWRlX2FjdGl2ZVxuICAgICAgICAgIHNjZW5lLmVtaXQoJ2N1c3RvbV9zbGlkZV9hY3RpdmUnLCB7XG4gICAgICAgICAgICBpbmRleDogc3RvcHMuaW5kZXhPZihzdG9wKSxcbiAgICAgICAgICAgIHNjcm9sbFRvOiBzY3JvbGxUb1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gX2RlZmF1bHQ7XG59KFBsdWdpbkJhc2UpO1xuXG5leHBvcnQgeyBfZGVmYXVsdCBhcyBkZWZhdWx0IH07IiwiaW1wb3J0IHRocm90dGxlIGZyb20gJ2xvZGFzaC50aHJvdHRsZSc7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnbG9kYXNoLmRlYm91bmNlJztcbmltcG9ydCBNb2pvIGZyb20gJy4vY29yZS9Nb2pvJztcbmltcG9ydCBNb2pvRnVzaW9uUGxheWVyIGZyb20gJy4vY29yZS9Nb2pvRnVzaW9uUGxheWVyJztcbmltcG9ydCBDb25zdCBmcm9tICcuL0NvbnN0JztcbmltcG9ydCBGeFNjYW5uZXIgZnJvbSAnLi9meC9GeFNjYW5uZXInO1xuaW1wb3J0IEZ4QmFzZSBmcm9tICcuL2Z4L0Z4QmFzZSc7XG5pbXBvcnQgTWFnbmV0IGZyb20gJy4vZngvZXhwZXJpbWVudGFsL01hZ25ldCc7XG5pbXBvcnQgQW5pbWVNYWduZXQgZnJvbSAnLi9meC9leHBlcmltZW50YWwvYW5pbWUvTWFnbmV0JztcbmltcG9ydCBUeXBlQW5pbWF0aW9uIGZyb20gJy4vZngvZXhwZXJpbWVudGFsL1R5cGVBbmltYXRpb24nO1xuaW1wb3J0IFBhcnRpY2xlcyBmcm9tICcuL2Z4L2V4cGVyaW1lbnRhbC9QYXJ0aWNsZXMnO1xuaW1wb3J0IFNwcml0ZXNoZWV0IGZyb20gJy4vZngvZXhwZXJpbWVudGFsL1Nwcml0ZXNoZWV0JztcbmltcG9ydCBKdW1wIGZyb20gJy4vZngvZXhwZXJpbWVudGFsL0p1bXAnO1xuaW1wb3J0IEhhbmRDdXJzb3IgZnJvbSAnLi9meC9leHBlcmltZW50YWwvSGFuZEN1cnNvcic7XG5pbXBvcnQgR2xpdGNoIGZyb20gJy4vZngvZXhwZXJpbWVudGFsL0dsaXRjaCc7XG5pbXBvcnQgRGVidWdnZXIgZnJvbSAnLi9meC9leHBlcmltZW50YWwvRGVidWdnZXInO1xuaW1wb3J0IEdsaXRjaENhbnZhcyBmcm9tICcuL2Z4L2V4cGVyaW1lbnRhbC9HbGl0Y2hDYW52YXMnO1xuaW1wb3J0IEdsaXRjaEVhc2VsIGZyb20gJy4vZngvZXhwZXJpbWVudGFsL0dsaXRjaEVhc2VsJztcbmltcG9ydCBHbGl0Y2hBcHBlYXIgZnJvbSAnLi9meC9leHBlcmltZW50YWwvR2xpdGNoQXBwZWFyJztcbmltcG9ydCBHbGl0Y2hJbk91dCBmcm9tICcuL2Z4L2V4cGVyaW1lbnRhbC9HbGl0Y2hJbk91dCc7XG5pbXBvcnQgUmVtb3ZlIGZyb20gJy4vZngvZXhwZXJpbWVudGFsL1JlbW92ZSc7XG5pbXBvcnQgUGFuWm9vbSBmcm9tICcuL2Z4L2V4cGVyaW1lbnRhbC9QYW5ab29tJztcbmltcG9ydCB7IEZ1c2lvbkhlbHBlciB9IGZyb20gJy4vY29yZS9GdXNpb25IZWxwZXInO1xuaW1wb3J0IFZpc3VhbERlYnVnZ2VyIGZyb20gJy4vcGx1Z2lucy93aXAvVmlzdWFsRGVidWdnZXInO1xuaW1wb3J0IFBhbm9yYW1hIGZyb20gJy4vcGx1Z2lucy93aXAvUGFub3JhbWEnO1xuaW1wb3J0ICcuLi9zdHlsZS9mdXNpb24uc2Nzcyc7IC8vIEdzYXAgRGVmYXVsdHNcblxuZ3NhcC5kZWZhdWx0cyh7XG4gIGVhc2U6IFwicG93ZXIyLmluT3V0XCIsXG4gIGR1cmF0aW9uOiAwLjVcbn0pO1xuZ3NhcC5jb25maWcoe1xuICBmb3JjZTNEOiB0cnVlXG59KTsgLy8gR2xvYmFsIE1vam8gaW5zdGFuY2Vcblxud2luZG93Lm1vam8gPSBuZXcgTW9qbygpOyAvLyBVc2UgTW9qbyBpbnN0YW5jZSBhcyBuYW1lc3BhY2UgZm9yIGFsbCBjbGFzc2VzXG5cbk9iamVjdC5hc3NpZ24od2luZG93Lm1vam8sIHtcbiAgTW9qb0Z1c2lvblBsYXllcjogTW9qb0Z1c2lvblBsYXllcixcbiAgRnVzaW9uSGVscGVyOiBGdXNpb25IZWxwZXIsXG4gIC8vICNUT0RPOiBEZWNpZGUgYmV0d2VlbiBGdXNpb25IZWxwZXIudGhyb3R0bGUgYW5kIGhlbHBlci50aHJvdHRsZSAobG9kYXNoKVxuICBoZWxwZXI6IHtcbiAgICB0aHJvdHRsZTogdGhyb3R0bGUsXG4gICAgZGVib3VuY2U6IGRlYm91bmNlXG4gIH0sXG4gIFwiY29uc3RcIjogQ29uc3QsXG4gIHBsdWdpbnM6IHtcbiAgICBQYW5vcmFtYTogUGFub3JhbWEsXG4gICAgVmlzdWFsRGVidWdnZXI6IFZpc3VhbERlYnVnZ2VyXG4gIH0sXG4gIGZ4OiB7XG4gICAgRnhCYXNlOiBGeEJhc2UsXG4gICAgRGVidWdnZXI6IERlYnVnZ2VyLFxuICAgIEZ4U2Nhbm5lcjogRnhTY2FubmVyLFxuICAgIE1hZ25ldDogTWFnbmV0LFxuICAgIFBhcnRpY2xlczogUGFydGljbGVzLFxuICAgIEhhbmRDdXJzb3I6IEhhbmRDdXJzb3IsXG4gICAgSnVtcDogSnVtcCxcbiAgICBHbGl0Y2g6IEdsaXRjaCxcbiAgICBHbGl0Y2hBcHBlYXI6IEdsaXRjaEFwcGVhcixcbiAgICBHbGl0Y2hJbk91dDogR2xpdGNoSW5PdXQsXG4gICAgR2xpdGNoQ2FudmFzOiBHbGl0Y2hDYW52YXMsXG4gICAgR2xpdGNoRWFzZWw6IEdsaXRjaEVhc2VsLFxuICAgIFR5cGVBbmltYXRpb246IFR5cGVBbmltYXRpb24sXG4gICAgU3ByaXRlc2hlZXQ6IFNwcml0ZXNoZWV0LFxuICAgIFJlbW92ZTogUmVtb3ZlLFxuICAgIFBhblpvb206IFBhblpvb20sXG4gICAgZXg6IHtcbiAgICAgIGFuaW1lOiB7XG4gICAgICAgIE1hZ25ldDogQW5pbWVNYWduZXRcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pOyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM3TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n')}]);